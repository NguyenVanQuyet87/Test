<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <title>WebXR AR với Marker Tracking và Hiệu Ứng Quét + Adjust</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { margin: 0; overflow: hidden; font-family: system-ui, sans-serif; }
    canvas { display: block; }
    #opacityControl {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10;
    }
    #info {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 10;
      background: rgba(0,0,0,0.4);
      color: white;
      padding: 6px 8px;
      font-family: monospace;
      font-size: 13px;
      border-radius: 6px;
      white-space: pre-line;
      max-width: 80%;
    }
    #resetBtn {
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 10;
      background: rgba(255,255,255,0.9);
      color: #111;
      padding: 6px 10px;
      font-family: system-ui, sans-serif;
      font-size: 13px;
      border: 1px solid #ccc;
      border-radius: 6px;
      cursor: pointer;
    }
    #markerStatus {
      position: absolute;
      bottom: 60px;
      left: 10px;
      z-index: 10;
      background: rgba(0,0,0,0.4);
      color: white;
      padding: 6px 8px;
      font-family: monospace;
      font-size: 13px;
      border-radius: 6px;
    }
    #placementBtn {
      position: absolute;
      bottom: 100px;
      right: 10px;
      z-index: 10;
      background: rgba(255,255,255,0.9);
      color: #111;
      padding: 8px 12px;
      font-family: system-ui, sans-serif;
      font-size: 13px;
      border: 1px solid #ccc;
      border-radius: 6px;
      cursor: pointer;
      display: none;
    }

    /* Adjust UI */
    #adjustBtn {
      position: absolute;
      right: 16px;
      top: 50%;
      transform: translateY(-50%);
      z-index: 20;
      background: rgba(255,255,255,0.95);
      color: #111;
      padding: 8px 12px;
      border-radius: 8px;
      border: 1px solid #ccc;
      cursor: pointer;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    }
    #adjustOverlay {
      position: absolute;
      inset: 0;
      z-index: 19;
      display: none;
      pointer-events: none; /* bật pointer cho child khi cần */
    }
    #adjustUI {
      position: absolute;
      inset: 0;
      pointer-events: auto;
    }
    /* Cross axes at center */
    .center-cross {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%,-50%);
      pointer-events: none;
      z-index: 21;
      width: 300px;
      height: 300px;
    }
    .axis-line {
      position: absolute;
      left: 50%;
      top: 50%;
      transform-origin: center;
      background: rgba(255,255,255,0.9);
    }
    .axis-x { width: 100%; height: 2px; transform: translate(-50%,-50%); }
    .axis-y { width: 2px; height: 100%; transform: translate(-50%,-50%); }
    .axis-label {
      position: absolute;
      color: white;
      font-size: 12px;
      background: rgba(0,0,0,0.5);
      padding: 2px 6px;
      border-radius: 4px;
    }
    .axis-label.x { left: calc(50% + 120px); top: 50%; transform: translateY(-50%); }
    .axis-label.y { top: calc(50% - 140px); left: 50%; transform: translateX(-50%); }

    /* Left vertical slider (height) */
    #leftControls {
      position: absolute;
      left: 12px;
      top: 50%;
      transform: translateY(-50%);
      z-index: 22;
      display: flex;
      align-items: center;
      gap: 8px;
      pointer-events: auto;
    }
    #zSlider {
      -webkit-appearance: none;
      appearance: none;
      width: 8px;
      height: 240px;
      transform: rotate(-90deg);
      transform-origin: center;
      cursor: pointer;
    }
    #zLabel {
      color: white;
      font-size: 13px;
      background: rgba(0,0,0,0.45);
      padding: 6px;
      border-radius: 6px;
      pointer-events: none;
    }

    /* Bottom rotation slider */
    #bottomControls {
      position: absolute;
      left: 50%;
      bottom: 12px;
      transform: translateX(-50%);
      z-index: 22;
      display: flex;
      align-items: center;
      gap: 8px;
      pointer-events: auto;
    }
    #rotSlider {
      width: 320px;
      cursor: pointer;
    }
    #rotLabel {
      color: white;
      font-size: 13px;
      background: rgba(0,0,0,0.45);
      padding: 6px;
      border-radius: 6px;
      pointer-events: none;
    }

    /* Drag instruction area (transparent) */
    #dragArea {
      position: absolute;
      left: 50%;
      top: 50%;
      width: 320px;
      height: 320px;
      transform: translate(-50%,-50%);
      z-index: 18;
      pointer-events: auto;
      background: rgba(0,0,0,0.0);
    }

    /* simple responsive tweaks */
    @media (max-width: 520px) {
      .center-cross { width: 220px; height: 220px; }
      #rotSlider { width: 220px; }
    }

    /* Hiệu ứng quét QR code */
    #markerOverlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 5;
      display: none;
    }
    .qr-frame {
      position: absolute;
      border: 4px solid transparent;
      border-radius: 12px;
      box-shadow: 0 0 20px rgba(255, 255, 0, 0.7);
      animation: pulse 1.5s infinite alternate;
    }
    .qr-corner {
      position: absolute;
      width: 20px;
      height: 20px;
      border: 4px solid #ff0;
    }
    .qr-corner-tl {
      top: -4px;
      left: -4px;
      border-right: none;
      border-bottom: none;
      border-top-left-radius: 8px;
    }
    .qr-corner-tr {
      top: -4px;
      right: -4px;
      border-left: none;
      border-bottom: none;
      border-top-right-radius: 8px;
    }
    .qr-corner-bl {
      bottom: -4px;
      left: -4px;
      border-right: none;
      border-top: none;
      border-bottom-left-radius: 8px;
    }
    .qr-corner-br {
      bottom: -4px;
      right: -4px;
      border-left: none;
      border-top: none;
      border-bottom-right-radius: 8px;
    }
    .scan-line {
      position: absolute;
      height: 3px;
      width: 100%;
      background: linear-gradient(to right, transparent, #ff0, transparent);
      top: 50%;
      animation: scan 2s linear infinite;
    }
    @keyframes pulse {
      0% { box-shadow: 0 0 10px rgba(255, 255, 0, 0.5); }
      100% { box-shadow: 0 0 30px rgba(255, 255, 0, 1); }
    }
    @keyframes scan {
      0% { top: 0%; opacity: 0; }
      10% { opacity: 1; }
      90% { opacity: 1; }
      100% { top: 100%; opacity: 0; }
    }
  </style>
</head>
<body>
  <div id="info">Đang chờ khởi động AR...</div>
  <div id="markerStatus">Chưa phát hiện marker</div>
  <button id="resetBtn" type="button">Reset AR</button>
  <button id="placementBtn" type="button">Đặt mô hình</button>
  <input type="range" id="opacityControl" min="0" max="1" step="0.05" value="1">
  
  <!-- Overlay hiệu ứng quét QR code -->
  <div id="markerOverlay">
    <div class="qr-frame">
      <div class="qr-corner qr-corner-tl"></div>
      <div class="qr-corner qr-corner-tr"></div>
      <div class="qr-corner qr-corner-bl"></div>
      <div class="qr-corner qr-corner-br"></div>
      <div class="scan-line"></div>
    </div>
  </div>

  <!-- Adjust button & overlay -->
  <button id="adjustBtn" title="Adjust model">Adjust</button>
  <div id="adjustOverlay">
    <div id="adjustUI">
      <div class="center-cross" aria-hidden="true">
        <div class="axis-line axis-x"></div>
        <div class="axis-line axis-y"></div>
        <div class="axis-label x">X</div>
        <div class="axis-label y">Y</div>
      </div>

      <div id="leftControls">
        <div id="zLabel">Z: <span id="zVal">0.00</span> m</div>
        <input id="zSlider" type="range" min="-1" max="2" step="0.01" value="0">
      </div>

      <div id="bottomControls">
        <div id="rotLabel">Rot: <span id="rotVal">0</span>°</div>
        <input id="rotSlider" type="range" min="-180" max="180" step="1" value="0">
      </div>

      <div id="dragArea" title="Tap + kéo: ngang → X, dọc → Y"></div>
    </div>
  </div>

  <script type="module">
  import * as THREE from "https://esm.sh/three@0.160.0";
  import { GLTFLoader } from "https://esm.sh/three@0.160.0/examples/jsm/loaders/GLTFLoader.js";
  import { ARButton } from "https://esm.sh/three@0.160.0/examples/jsm/webxr/ARButton.js";

  const infoEl = document.getElementById("info");
  const markerStatusEl = document.getElementById("markerStatus");
  const resetBtn = document.getElementById("resetBtn");
  const placementBtn = document.getElementById("placementBtn");
  const markerOverlay = document.getElementById("markerOverlay");
  const qrFrame = document.querySelector('.qr-frame');

  // Adjust UI elements
  const adjustBtn = document.getElementById('adjustBtn');
  const adjustOverlay = document.getElementById('adjustOverlay');
  const dragArea = document.getElementById('dragArea');
  const zSlider = document.getElementById('zSlider');
  const rotSlider = document.getElementById('rotSlider');
  const zVal = document.getElementById('zVal');
  const rotVal = document.getElementById('rotVal');

  let modelTemplate = null;
  let currentAnchor = null;
  let reticle;
  let hitTestSource = null;
  let lastHitResult = null;
  let currentModel = null;            // mesh/group we visually placed (the placed model)
  let currentRootGroup = null;        // top-level group that may have anchors (group.matrixAutoUpdate=false)
  let currentInteractiveGroup = null; // wrapper under root group with matrixAutoUpdate=true for moving/rotating/height
  let isDragging = false;
  let previousPointer = null;
  let markerDetected = false;
  let markerPose = null;
  const allAnchors = new Set();

  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.01, 20);
  const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.xr.enabled = true;
  document.body.appendChild(renderer.domElement);

  const PLACEMENTS_ROOT = new THREE.Group();
  scene.add(PLACEMENTS_ROOT);

  // Hàm cập nhật vị trí và kích thước của hiệu ứng quét QR dựa trên vị trí marker
  function updateQRFramePosition(pose) {
    if (!pose) return;
    const matrix = new THREE.Matrix4().fromArray(pose.transform.matrix);
    const position = new THREE.Vector3();
    const scale = new THREE.Vector3();
    const quaternion = new THREE.Quaternion();
    matrix.decompose(position, quaternion, scale);
    const vector = position.clone();
    vector.project(camera);
    const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
    const y = -(vector.y * 0.5 - 0.5) * window.innerHeight;
    const distance = position.distanceTo(camera.position);
    const markerSize = (0.15 / Math.max(distance, 0.1)) * 500;
    qrFrame.style.width = `${markerSize}px`;
    qrFrame.style.height = `${markerSize}px`;
    qrFrame.style.left = `${x - markerSize/2}px`;
    qrFrame.style.top = `${y - markerSize/2}px`;
    markerOverlay.style.display = 'block';
  }

  function hideQRFrame() { markerOverlay.style.display = 'none'; }

  async function initARButton() {
    if (!("xr" in navigator)) { infoEl.textContent = "Trình duyệt không hỗ trợ WebXR."; return; }
    const supported = await navigator.xr.isSessionSupported("immersive-ar");
    if (!supported) { infoEl.textContent = "Thiết bị không hỗ trợ AR."; return; }
    try {
      const imgBitmap = await fetch("marker.png")
        .then(r => r.blob())
        .then(b => createImageBitmap(b));
      document.body.appendChild(ARButton.createButton(renderer, {
        requiredFeatures: ["image-tracking"],
        trackedImages: [{ image: imgBitmap, widthInMeters: 0.15 }],
        optionalFeatures: ["hit-test", "anchors", "dom-overlay"],
        domOverlay: { root: document.body }
      }));
    } catch (e) {
      console.error("Lỗi khi tải marker:", e);
      infoEl.textContent = "Lỗi khi tải marker.png - vui lòng kiểm tra file và console";
    }
  }
  initARButton();

  scene.add(new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1));

  const ringGeo = new THREE.RingGeometry(0.08,0.1,32).rotateX(-Math.PI/2);
  const ringMat = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
  reticle = new THREE.Mesh(ringGeo, ringMat);
  reticle.matrixAutoUpdate = false;
  reticle.visible = false;
  scene.add(reticle);

  function createFallbackModel() {
    const geometry = new THREE.BoxGeometry(0.1, 0.1, 0.1);
    const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
    const cube = new THREE.Mesh(geometry, material);
    const group = new THREE.Group();
    group.add(cube);
    group.scale.set(0.2, 0.2, 0.2);
    return group;
  }

  const loader = new GLTFLoader();
  loader.load("test.glb", (gltf)=>{
    modelTemplate = gltf.scene;
    modelTemplate.scale.set(0.2,0.2,0.2);
    // Xoay từ hệ glTF (+Y up) sang hệ WebXR nếu cần
    modelTemplate.rotation.x = Math.PI / 2;
    infoEl.textContent = "Model đã load — di chuyển camera để tìm mặt phẳng hoặc marker.";
  }, undefined, (err)=>{
    console.error("GLTF load error:", err);
    infoEl.textContent = "Lỗi load GLTF — tạo model mẫu thay thế.";
    modelTemplate = createFallbackModel();
  });

  function cloneModel(template) {
    const clone = template.clone(true);
    clone.traverse((n)=>{
      if (n.isMesh && n.material) {
        n.material = n.material.clone();
        n.material.transparent = true;
        n.material.userData.__cloned = true;
      }
    });
    return clone;
  }

  function clearAllPlacementsAndAnchors() {
    if (allAnchors.size) {
      for (const a of allAnchors) { try { if (a.delete) a.delete(); } catch(e){} }
      allAnchors.clear();
    }
    while (PLACEMENTS_ROOT.children.length) {
      const child = PLACEMENTS_ROOT.children[0];
      PLACEMENTS_ROOT.remove(child);
    }
    currentAnchor = null;
    currentModel = null;
    currentRootGroup = null;
    currentInteractiveGroup = null;
  }

  // Tạo một wrapper interactionGroup để dễ di chuyển/rotate/height
  function createInteractiveWrapper(rootGroup, placed) {
    // đặt interactionGroup làm con của rootGroup; rootGroup có thể là anchored group (matrixAutoUpdate=false)
    const interaction = new THREE.Group();
    interaction.name = 'interactionGroup';
    interaction.position.set(0,0,0);
    interaction.matrixAutoUpdate = true;
    rootGroup.add(interaction);
    interaction.add(placed);
    return interaction;
  }

  // place model on marker (poses from image tracking)
  function placeModelOnMarker(pose) {
    if (!modelTemplate || isPlacing) return;
    isPlacing = true;
    clearAllPlacementsAndAnchors();

    const group = new THREE.Group();
    group.matrixAutoUpdate = false;

    const matrix = new THREE.Matrix4().fromArray(pose.transform.matrix);
    const position = new THREE.Vector3();
    const quaternion = new THREE.Quaternion();
    const scale = new THREE.Vector3();
    matrix.decompose(position, quaternion, scale);

    // Build a simple orientation so model's "up" aligns with marker normal
    const localY = new THREE.Vector3(0,1,0).applyQuaternion(quaternion).normalize(); // normal
    // pick camera forward to determine X axis
    const camFwd = new THREE.Vector3();
    camera.getWorldDirection(camFwd);
    camFwd.y = 0; camFwd.normalize();
    const xAxis = camFwd.clone().projectOnPlane(localY).normalize();
    if (xAxis.length() < 1e-3) xAxis.set(1,0,0);
    const zAxis = new THREE.Vector3().crossVectors(localY, xAxis).normalize();
    const modelMat = new THREE.Matrix4().makeBasis(xAxis, localY, zAxis);
    modelMat.setPosition(position);
    group.matrix.copy(modelMat);

    PLACEMENTS_ROOT.add(group);
    currentRootGroup = group;

    const placed = cloneModel(modelTemplate);
    // add an interaction wrapper so we can translate/rotate/height easily
    currentInteractiveGroup = createInteractiveWrapper(group, placed);
    currentModel = placed;

    // create anchor if possible
    if (pose && pose.createAnchor) {
      pose.createAnchor().then(anchor => {
        currentAnchor = { anchor, group };
        allAnchors.add(anchor);
      }).catch(console.error);
    }

    infoEl.textContent = "Model đã được đặt trên marker! Bạn có thể nhấn Adjust để điều chỉnh.";
    isPlacing = false;
    markerDetected = false;
    hideQRFrame();

    // cập nhật UI sliders theo giá trị hiện tại
    updateSlidersFromModel();
  }

  // debug axes (small visual helper)
  function debugAxes(group, xAxis, yAxis, zAxis) {
    const axisLength = 0.2;
    const xGeometry = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(axisLength, 0, 0)]);
    const xMaterial = new THREE.LineBasicMaterial({ color: 0xff0000 });
    const xAxisLine = new THREE.Line(xGeometry, xMaterial);
    group.add(xAxisLine);
    const yGeometry = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, axisLength, 0)]);
    const yMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00 });
    const yAxisLine = new THREE.Line(yGeometry, yMaterial);
    group.add(yAxisLine);
    const zGeometry = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, axisLength)]);
    const zMaterial = new THREE.LineBasicMaterial({ color: 0x0000ff });
    const zAxisLine = new THREE.Line(zGeometry, zMaterial);
    group.add(zAxisLine);
  }

  // --- orientation helpers ---
  let _lastHDir = new THREE.Vector3(1, 0, 0);
  function getCameraHorizontalDir() {
    const fwd = new THREE.Vector3();
    camera.getWorldDirection(fwd);
    fwd.y = 0;
    const len = fwd.length();
    if (len < 1e-3) return _lastHDir.clone();
    fwd.divideScalar(len);
    _lastHDir.copy(fwd);
    return fwd;
  }

  function computePlacementMatrixFromMatrix(baseMatrix) {
    const poseMat = new THREE.Matrix4().copy(baseMatrix);
    const rotMat = new THREE.Matrix4().extractRotation(poseMat);
    const normal = new THREE.Vector3(0,1,0).applyMatrix4(rotMat).normalize();
    const camFwd = getCameraHorizontalDir();
    const camProj = camFwd.clone().projectOnPlane(normal);
    if (camProj.length() < 1e-3) {
      camProj.copy(_lastHDir).projectOnPlane(normal);
      if (camProj.length() < 1e-3) camProj.set(1,0,0);
    }
    camProj.normalize();
    const xAxis = camProj.clone();
    const zAxis = normal.clone().normalize();
    const yAxis = new THREE.Vector3().crossVectors(zAxis, xAxis).normalize();
    const basis = new THREE.Matrix4().makeBasis(xAxis, yAxis, zAxis);
    const pos = new THREE.Vector3().setFromMatrixPosition(poseMat);
    basis.setPosition(pos);
    return basis;
  }

  async function placeAnchorFromLastHit() {
    if (isPlacing) return;
    isPlacing = true;
    const hit = lastHitResult;
    const refSpace = renderer.xr.getReferenceSpace();
    if (!hit || !refSpace || !modelTemplate) { isPlacing=false; return; }
    clearAllPlacementsAndAnchors();
    const pose = hit.getPose(refSpace);
    const anchor = await hit.createAnchor?.(refSpace).catch(()=>null);
    const group = new THREE.Group();
    group.matrixAutoUpdate=false;
    if (pose) {
      const placementMatrix = computePlacementMatrixFromMatrix(new THREE.Matrix4().fromArray(pose.transform.matrix));
      group.matrix.copy(placementMatrix);
    }
    PLACEMENTS_ROOT.add(group);
    currentRootGroup = group;
    const placed = cloneModel(modelTemplate);
    currentInteractiveGroup = createInteractiveWrapper(group, placed);
    currentModel = placed;
    currentAnchor = { anchor, group };
    if (anchor) allAnchors.add(anchor);
    isPlacing=false;
    updateSlidersFromModel();
  }

  const controller = renderer.xr.getController(0);
  controller.addEventListener("select", ()=>{ if (reticle.visible) placeAnchorFromLastHit(); });
  scene.add(controller);

  window.addEventListener("click", ()=>{ 
    const s=renderer.xr.getSession(); 
    if (s && reticle.visible) placeAnchorFromLastHit(); 
  });

  placementBtn.addEventListener("click", ()=>{
    if (markerPose) {
      placeModelOnMarker(markerPose);
      placementBtn.style.display = 'none';
    }
  });

  document.getElementById("opacityControl").addEventListener("input",(e)=>{
    const v = parseFloat(e.target.value);
    if (currentModel) {
      currentModel.traverse((n)=>{ if (n.isMesh && n.material) n.material.opacity=v; });
    }
  });

  resetBtn.addEventListener("click",()=>{ 
    const s=renderer.xr.getSession(); 
    if (s) s.end(); 
    hideQRFrame();
  });

  // Adjust UI toggle
  adjustBtn.addEventListener('click', ()=>{
    if (adjustOverlay.style.display === 'block') {
      adjustOverlay.style.display = 'none';
      adjustBtn.textContent = 'Adjust';
    } else {
      adjustOverlay.style.display = 'block';
      adjustBtn.textContent = 'Close';
    }
  });

  // Update sliders to reflect current model transform
  function updateSlidersFromModel() {
    if (!currentInteractiveGroup) return;
    // Treat Y as up in our placements (consistent with computePlacementMatrixFromMatrix)
    const pos = currentInteractiveGroup.position;
    zSlider.value = pos.y.toFixed(2); // slider mapped to Y (height)
    zVal.textContent = Number(pos.y).toFixed(2);
    // rotation around up axis (Y)
    const euler = new THREE.Euler().setFromQuaternion(currentInteractiveGroup.quaternion, 'YXZ');
    const deg = THREE.MathUtils.radToDeg(euler.y);
    rotSlider.value = deg.toFixed(0);
    rotVal.textContent = deg.toFixed(0);
  }

  // zSlider affects **height** (Y axis) — vì trong code trước chúng dùng Y làm normal/up
  zSlider.addEventListener('input', ()=>{
    if (!currentInteractiveGroup) return;
    const v = parseFloat(zSlider.value);
    currentInteractiveGroup.position.y = v;
    zVal.textContent = v.toFixed(2);
  });

  // rotSlider rotates around up axis (world Y)
  rotSlider.addEventListener('input', ()=>{
    if (!currentInteractiveGroup) return;
    const deg = parseFloat(rotSlider.value);
    rotVal.textContent = deg.toFixed(0);
    // set rotation around Y
    currentInteractiveGroup.rotation.set(0, THREE.MathUtils.degToRad(deg), 0);
  });

  // Drag to translate in X and Z-plane (we map drag X → X, drag Y → Z in world plane parallel to ground)
  // But user requested drag X → X, drag Y → Y. Because in our placement 'Y' is up, we will interpret:
  // horizontal drag → world X, vertical drag → world Z (forward/back on ground plane).
  // To match their wording loosely: X and Y "in-plane" (we show labels X and Y in UI), but in 3D ground plane we'll move X and Z.
  let pointerActive = false;
  let startPointer = null;
  let startModelPos = new THREE.Vector3();
  function pointerDown(e) {
    if (!currentInteractiveGroup) return;
    e.preventDefault();
    pointerActive = true;
    previousPointer = { x: e.clientX, y: e.clientY, id: e.pointerId };
    startPointer = { x: e.clientX, y: e.clientY };
    // store start pos in world
    startModelPos.copy(currentInteractiveGroup.position);
    dragArea.setPointerCapture(e.pointerId);
  }
  function pointerMove(e) {
    if (!pointerActive || !currentInteractiveGroup || !startPointer) return;
    e.preventDefault();
    const dx = e.clientX - startPointer.x;
    const dy = e.clientY - startPointer.y;
    // compute a sensible scale: relate pixels to meters by distance from camera to model
    const worldPos = new THREE.Vector3();
    currentRootGroup.getWorldPosition(worldPos);
    const distance = camera.position.distanceTo(worldPos) || 1;
    // sensitivity: pixels → meters (tweakable)
    const sensitivity = 0.0015 * distance; // adjust factor if movement too fast/slow
    // horizontal drag -> world X
    const deltaX = dx * sensitivity;
    // vertical drag -> world Z (forward/back on ground plane)
    const deltaZ = -dy * sensitivity;
    // apply in local ground-frame of rootGroup: we want X and forward relative to camera orientation.
    // We'll compute camera horizontal direction as forward, and right vector as cross(forward, up).
    const camFwd = new THREE.Vector3();
    camera.getWorldDirection(camFwd);
    camFwd.y = 0; camFwd.normalize();
    const up = new THREE.Vector3(0,1,0);
    const camRight = new THREE.Vector3().crossVectors(camFwd, up).normalize();

    // new position = start + right*deltaX + forward*deltaZ
    const newPos = startModelPos.clone();
    newPos.add(camRight.multiplyScalar(deltaX));
    newPos.add(camFwd.multiplyScalar(deltaZ));

    // But currentInteractiveGroup.position is local to rootGroup; convert world delta to local
    // Compute rootGroup world matrix inverse to transform newPos into rootGroup local coordinates
    const rootWorldInv = new THREE.Matrix4().copy(currentRootGroup.matrixWorld).invert();
    const localPos = newPos.clone().applyMatrix4(rootWorldInv);

    currentInteractiveGroup.position.copy(localPos);
    // update sliders if needed
    zSlider.value = currentInteractiveGroup.position.y.toFixed(2);
    zVal.textContent = currentInteractiveGroup.position.y.toFixed(2);
    // update rotation slider display but don't change rotation
    const euler = new THREE.Euler().setFromQuaternion(currentInteractiveGroup.quaternion, 'YXZ');
    rotVal.textContent = THREE.MathUtils.radToDeg(euler.y).toFixed(0);
  }
  function pointerUp(e) {
    if (!pointerActive) return;
    pointerActive = false;
    startPointer = null;
    try { dragArea.releasePointerCapture(e.pointerId); } catch(_) {}
  }

  // Add pointer events on dragArea
  dragArea.addEventListener('pointerdown', pointerDown);
  window.addEventListener('pointermove', pointerMove);
  window.addEventListener('pointerup', pointerUp);
  window.addEventListener('pointercancel', pointerUp);

  // Tương tác chạm cho mobile (touch) đã được bao bởi pointer events trên hầu hết trình duyệt hiện đại.

  // Raycaster and center hits (kept original)
  const raycaster = new THREE.Raycaster();
  const center = new THREE.Vector2(0, 0);
  function getIntersects() {
    const offsets = [
      new THREE.Vector2(0, 0),
      new THREE.Vector2(0.01, 0),
      new THREE.Vector2(-0.01, 0),
      new THREE.Vector2(0, 0.01),
      new THREE.Vector2(0, -0.01)
    ];
    let allHits = [];
    offsets.forEach(off => {
      const ndc = new THREE.Vector2(center.x + off.x, center.y + off.y);
      raycaster.setFromCamera(ndc, camera);
      const hits = raycaster.intersectObjects(scene.children, true);
      if (hits.length > 0) allHits.push(hits[0]);
    });
    if (allHits.length > 0) {
      allHits.sort((a, b) => a.distance - b.distance);
      return allHits[0];
    }
    return null;
  }

  // Session start
  renderer.xr.addEventListener("sessionstart", async ()=>{
    const session = renderer.xr.getSession();
    infoEl.textContent = "Đã vào chế độ AR, di chuyển để quét mặt phẳng hoặc marker...";
    const viewerSpace = await session.requestReferenceSpace("viewer");
    hitTestSource = await session.requestHitTestSource({ space: viewerSpace }).catch(()=>null);
    session.addEventListener("end", ()=>{ 
      hitTestSource = null; 
      clearAllPlacementsAndAnchors(); 
      infoEl.textContent = "AR session đã kết thúc.";
      markerStatusEl.textContent = "Chưa phát hiện marker";
      placementBtn.style.display = 'none';
      markerDetected = false;
      hideQRFrame();
      adjustOverlay.style.display = 'none';
      adjustBtn.textContent = 'Adjust';
    });
  });

  let isPlacing = false;
  renderer.setAnimationLoop((t,frame)=>{
    if (frame) {
      const refSpace = renderer.xr.getReferenceSpace();
      if (hitTestSource && refSpace) {
        const hits = frame.getHitTestResults(hitTestSource);
        if (hits.length>0) {
          lastHitResult = hits[0];
          const pose = hits[0].getPose(refSpace);
          if (pose) { reticle.visible=true; reticle.matrix.fromArray(pose.transform.matrix); }
        } else { reticle.visible=false; }
      }

      // image tracking
      const results = frame.getImageTrackingResults ? frame.getImageTrackingResults() : [];
      if (results.length > 0) {
        for (const result of results) {
          const state = result.trackingState;
          if (state === "tracked") {
            const pose = frame.getPose(result.imageSpace, refSpace);
            if (pose) {
              const p = pose.transform.position;
              markerStatusEl.textContent = 
                `Marker được nhận diện!\n`+
                `Vị trí: x=${p.x.toFixed(2)}, y=${p.y.toFixed(2)}, z=${p.z.toFixed(2)}`;
              updateQRFramePosition(pose);
              markerPose = pose;
              if (!currentModel && modelTemplate && !markerDetected) {
                markerDetected = true;
                placementBtn.style.display = 'block';
                placementBtn.textContent = 'Đặt mô hình lên marker';
                setTimeout(() => {
                  if (markerDetected && markerPose) {
                    placeModelOnMarker(markerPose);
                    placementBtn.style.display = 'none';
                  }
                }, 2000);
              }
            }
          } else {
            markerStatusEl.textContent = `Marker trạng thái: ${state}`;
            markerDetected = false;
            placementBtn.style.display = 'none';
            hideQRFrame();
          }
        }
      } else {
        markerStatusEl.textContent = "Chưa phát hiện marker";
        markerDetected = false;
        placementBtn.style.display = 'none';
        hideQRFrame();
      }

      // Raycast center to show selection (kept)
      const hit = getIntersects();
      if (hit) {
        const obj = hit.object;
        if (obj.material && obj.material.color) {
          obj.material.color.set(0xff0000);
        }
        infoEl.textContent = `Chọn: ${obj.name || obj.uuid}`;
      }
    }
    renderer.render(scene,camera);
  });

  // touch rotate existing model (kept)
  renderer.domElement.addEventListener("touchstart",(e)=>{ if (e.touches.length===1) { isDragging=true; previousTouchX=e.touches[0].clientX; } });
  renderer.domElement.addEventListener("touchmove",(e)=>{ 
    if (isDragging && currentModel && e.touches.length===1) { 
      const dx=e.touches[0].clientX-previousTouchX; 
      previousTouchX=e.touches[0].clientX; 
      currentModel.rotation.y += dx*0.01; 
      // sync rot slider (approx)
      if (currentInteractiveGroup) {
        const deg = THREE.MathUtils.radToDeg(currentInteractiveGroup.rotation.y);
        rotSlider.value = deg.toFixed(0);
        rotVal.textContent = deg.toFixed(0);
      }
    } 
  });
  renderer.domElement.addEventListener("touchend",()=>{ isDragging=false; });

  window.addEventListener("resize",()=>{ 
    camera.aspect = window.innerWidth/window.innerHeight; 
    camera.updateProjectionMatrix(); 
    renderer.setSize(window.innerWidth, window.innerHeight); 
  });

  </script>
</body>
</html>
