<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <title>WebXR AR v·ªõi Marker Tracking v√† Hi·ªáu ·ª®ng Qu√©t</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
    #opacityControl {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10;
    }
    #info {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 10;
      background: rgba(0,0,0,0.4);
      color: white;
      padding: 6px 8px;
      font-family: monospace;
      font-size: 13px;
      border-radius: 6px;
      white-space: pre-line;
      max-width: 80%;
    }
    #resetBtn {
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 10;
      background: rgba(255,255,255,0.9);
      color: #111;
      padding: 6px 10px;
      font-family: system-ui, sans-serif;
      font-size: 13px;
      border: 1px solid #ccc;
      border-radius: 6px;
      cursor: pointer;
    }
    #markerStatus {
      position: absolute;
      bottom: 60px;
      left: 10px;
      z-index: 10;
      background: rgba(0,0,0,0.4);
      color: white;
      padding: 6px 8px;
      font-family: monospace;
      font-size: 13px;
      border-radius: 6px;
    }
    #placementBtn {
      position: absolute;
      bottom: 100px;
      right: 10px;
      z-index: 10;
      background: rgba(255,255,255,0.9);
      color: #111;
      padding: 8px 12px;
      font-family: system-ui, sans-serif;
      font-size: 13px;
      border: 1px solid #ccc;
      border-radius: 6px;
      cursor: pointer;
      display: none;
    }
    /* Hi·ªáu ·ª©ng qu√©t QR code */
    #markerOverlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 5;
      display: none;
    }
    .qr-frame {
      position: absolute;
      border: 4px solid transparent;
      border-radius: 12px;
      box-shadow: 0 0 20px rgba(255, 255, 0, 0.7);
      animation: pulse 1.5s infinite alternate;
    }
    .qr-corner {
      position: absolute;
      width: 20px;
      height: 20px;
      border: 4px solid #ff0;
    }
    .qr-corner-tl {
      top: -4px;
      left: -4px;
      border-right: none;
      border-bottom: none;
      border-top-left-radius: 8px;
    }
    .qr-corner-tr {
      top: -4px;
      right: -4px;
      border-left: none;
      border-bottom: none;
      border-top-right-radius: 8px;
    }
    .qr-corner-bl {
      bottom: -4px;
      left: -4px;
      border-right: none;
      border-top: none;
      border-bottom-left-radius: 8px;
    }
    .qr-corner-br {
      bottom: -4px;
      right: -4px;
      border-left: none;
      border-top: none;
      border-bottom-right-radius: 8px;
    }
    .scan-line {
      position: absolute;
      height: 3px;
      width: 100%;
      background: linear-gradient(to right, transparent, #ff0, transparent);
      top: 50%;
      animation: scan 2s linear infinite;
    }
    @keyframes pulse {
      0% { box-shadow: 0 0 10px rgba(255, 255, 0, 0.5); }
      100% { box-shadow: 0 0 30px rgba(255, 255, 0, 1); }
    }
    @keyframes scan {
      0% { top: 0%; opacity: 0; }
      10% { opacity: 1; }
      90% { opacity: 1; }
      100% { top: 100%; opacity: 0; }
    }
    
    /* Giao di·ªán ƒëi·ªÅu khi·ªÉn m·ªõi */
    #controlPanel {
      position: absolute;
      top: 50%;
      right: 10px;
      transform: translateY(-50%);
      display: flex;
      flex-direction: column;
      gap: 10px;
      z-index: 10;
      display: none;
    }
    .control-btn {
      width: 44px;
      height: 44px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.9);
      border: 1px solid #ccc;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      cursor: pointer;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    }
    #adjustmentPanel {
      position: absolute;
      left: 10px;
      bottom: 100px;
      background: rgba(255, 255, 255, 0.85);
      border-radius: 10px;
      padding: 15px;
      z-index: 10;
      display: none;
      flex-direction: column;
      gap: 15px;
      min-width: 200px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    }
    .slider-container {
      display: flex;
      flex-direction: column;
      gap: 5px;
    }
    .slider-container label {
      font-family: system-ui, sans-serif;
      font-size: 14px;
      color: #333;
    }
    .axis-controls {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      grid-template-rows: 1fr 1fr 1fr;
      gap: 5px;
      margin: 10px 0;
    }
    .axis-btn {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.9);
      border: 1px solid #ccc;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      cursor: pointer;
    }
    .axis-btn:nth-child(2) {
      grid-column: 2;
      grid-row: 1;
    }
    .axis-btn:nth-child(1) {
      grid-column: 1;
      grid-row: 2;
    }
    .axis-btn:nth-child(3) {
      grid-column: 3;
      grid-row: 2;
    }
    .axis-btn:nth-child(4) {
      grid-column: 2;
      grid-row: 3;
    }
    .center-indicator {
      grid-column: 2;
      grid-row: 2;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: #f00;
      margin: auto;
    }
    #toggleAdjustPanel {
      position: absolute;
      bottom: 10px;
      right: 10px;
      z-index: 10;
    }
  </style>
</head>
<body>
  <div id="info">ƒêang ch·ªù kh·ªüi ƒë·ªông AR...</div>
  <div id="markerStatus">Ch∆∞a ph√°t hi·ªán marker</div>
  <button id="resetBtn" type="button">Reset AR</button>
  <button id="placementBtn" type="button">ƒê·∫∑t m√¥ h√¨nh</button>
  <input type="range" id="opacityControl" min="0" max="1" step="0.05" value="1">
  
  <!-- Overlay hi·ªáu ·ª©ng qu√©t QR code -->
  <div id="markerOverlay">
    <div class="qr-frame">
      <div class="qr-corner qr-corner-tl"></div>
      <div class="qr-corner qr-corner-tr"></div>
      <div class="qr-corner qr-corner-bl"></div>
      <div class="qr-corner qr-corner-br"></div>
      <div class="scan-line"></div>
    </div>
  </div>

  <!-- Giao di·ªán ƒëi·ªÅu khi·ªÉn m·ªõi -->
  <div id="controlPanel">
    <button class="control-btn" id="toggleVisibility">üëÅÔ∏è</button>
    <button class="control-btn" id="adjustPosition">‚ú•</button>
    <button class="control-btn" id="resetPosition">‚Ü∫</button>
  </div>

  <div id="adjustmentPanel">
    <h3 style="margin: 0 0 15px 0; font-family: system-ui;">ƒêi·ªÅu ch·ªânh v·ªã tr√≠</h3>
    
    <div class="axis-controls">
      <button class="axis-btn" id="moveLeft">‚Üê</button>
      <button class="axis-btn" id="moveForward">‚Üë</button>
      <button class="axis-btn" id="moveRight">‚Üí</button>
      <div class="center-indicator"></div>
      <button class="axis-btn" id="moveBackward">‚Üì</button>
    </div>
    
    <div class="slider-container">
      <label for="heightSlider">ƒê·ªô cao: <span id="heightValue">0.0</span>m</label>
      <input type="range" id="heightSlider" min="-0.5" max="0.5" step="0.01" value="0">
    </div>
    
    <div class="slider-container">
      <label for="rotationSlider">G√≥c quay: <span id="rotationValue">0</span>¬∞</label>
      <input type="range" id="rotationSlider" min="-180" max="180" step="1" value="0">
    </div>
    
    <button id="closeAdjustPanel" style="padding: 8px; background: #f0f0f0; border: 1px solid #ccc; border-radius: 5px;">ƒê√≥ng</button>
  </div>

  <button class="control-btn" id="toggleAdjustPanel" style="display: none;">‚öôÔ∏è</button>

  <script type="module">
  import * as THREE from "https://esm.sh/three@0.160.0";
  import { GLTFLoader } from "https://esm.sh/three@0.160.0/examples/jsm/loaders/GLTFLoader.js";
  import { ARButton } from "https://esm.sh/three@0.160.0/examples/jsm/webxr/ARButton.js";

  const infoEl = document.getElementById("info");
  const markerStatusEl = document.getElementById("markerStatus");
  const resetBtn = document.getElementById("resetBtn");
  const placementBtn = document.getElementById("placementBtn");
  const markerOverlay = document.getElementById("markerOverlay");
  const qrFrame = document.querySelector('.qr-frame');
  const controlPanel = document.getElementById("controlPanel");
  const adjustmentPanel = document.getElementById("adjustmentPanel");
  const toggleAdjustPanel = document.getElementById("toggleAdjustPanel");
  const toggleVisibilityBtn = document.getElementById("toggleVisibility");
  const adjustPositionBtn = document.getElementById("adjustPosition");
  const resetPositionBtn = document.getElementById("resetPosition");
  const closeAdjustPanel = document.getElementById("closeAdjustPanel");

  let modelTemplate = null;
  let currentAnchor = null;
  let reticle;
  let hitTestSource = null;
  let lastHitResult = null;
  let currentModel = null;
  let isDragging = false;
  let previousTouchX = 0;
  let isPlacing = false;
  let markerDetected = false;
  let markerPose = null;
  let isAdjustmentMode = false;
  let originalModelPosition = new THREE.Vector3();
  let originalModelRotation = new THREE.Euler();
  let originalModelScale = new THREE.Vector3();
  const allAnchors = new Set();

  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.01, 20);
  const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.xr.enabled = true;
  document.body.appendChild(renderer.domElement);

  const PLACEMENTS_ROOT = new THREE.Group();
  scene.add(PLACEMENTS_ROOT);

  // H√†m c·∫≠p nh·∫≠t v·ªã tr√≠ v√† k√≠ch th∆∞·ªõc c·ªßa hi·ªáu ·ª©ng qu√©t QR d·ª±a tr√™n v·ªã tr√≠ marker
  function updateQRFramePosition(pose) {
    if (!pose) return;
    
    // L·∫•y ma tr·∫≠n chuy·ªÉn ƒë·ªïi t·ª´ pose
    const matrix = new THREE.Matrix4().fromArray(pose.transform.matrix);
    const position = new THREE.Vector3();
    const scale = new THREE.Vector3();
    const quaternion = new THREE.Quaternion();
    matrix.decompose(position, quaternion, scale);
    
    // Chuy·ªÉn ƒë·ªïi v·ªã tr√≠ 3D sang t·ªça ƒë·ªô m√†n h√¨nh 2D
    const vector = position.clone();
    vector.project(camera);
    
    const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
    const y = -(vector.y * 0.5 - 0.5) * window.innerHeight;
    
    // ∆Ø·ªõc t√≠nh k√≠ch th∆∞·ªõc c·ªßa marker tr√™n m√†n h√¨nh d·ª±a tr√™n kho·∫£ng c√°ch
    const distance = position.distanceTo(camera.position);
    const markerSize = (0.15 / distance) * 500; // 0.15 l√† widthInMeters c·ªßa marker
    
    // C·∫≠p nh·∫≠t v·ªã tr√≠ v√† k√≠ch th∆∞·ªõc c·ªßa khung QR
    qrFrame.style.width = `${markerSize}px`;
    qrFrame.style.height = `${markerSize}px`;
    qrFrame.style.left = `${x - markerSize/2}px`;
    qrFrame.style.top = `${y - markerSize/2}px`;
    
    // Hi·ªÉn th·ªã overlay
    markerOverlay.style.display = 'block';
  }

  // ·∫®n hi·ªáu ·ª©ng qu√©t QR
  function hideQRFrame() {
    markerOverlay.style.display = 'none';
  }

  async function initARButton() {
    if (!("xr" in navigator)) { infoEl.textContent = "Tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ WebXR."; return; }
    const supported = await navigator.xr.isSessionSupported("immersive-ar");
    if (!supported) { infoEl.textContent = "Thi·∫øt b·ªã kh√¥ng h·ªó tr·ª£ AR."; return; }
    // Load marker image
    try {
      const imgBitmap = await fetch("marker.png")
        .then(r => r.blob())
        .then(b => createImageBitmap(b));
      
      document.body.appendChild(ARButton.createButton(renderer, {
        requiredFeatures: ["image-tracking"],
        trackedImages: [
          {
            image: imgBitmap,
            widthInMeters: 0.15
          }
        ],
        optionalFeatures: ["hit-test", "anchors", "dom-overlay"],
        domOverlay: { root: document.body }
      }));
    } catch (e) {
      console.error("L·ªói khi t·∫£i marker:", e);
      infoEl.textContent = "L·ªói khi t·∫£i marker.png - vui l√≤ng ki·ªÉm tra file v√† console";
    }
  }
  initARButton();

  scene.add(new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1));

  const ringGeo = new THREE.RingGeometry(0.08,0.1,32).rotateX(-Math.PI/2);
  const ringMat = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
  reticle = new THREE.Mesh(ringGeo, ringMat);
  reticle.matrixAutoUpdate = false;
  reticle.visible = false;
  scene.add(reticle);

  // T·∫°o h√¨nh kh·ªëi m·∫´u n·∫øu kh√¥ng t·∫£i ƒë∆∞·ª£c GLTF
  function createFallbackModel() {
    const geometry = new THREE.BoxGeometry(0.1, 0.1, 0.1);
    const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
    const cube = new THREE.Mesh(geometry, material);
    const group = new THREE.Group();
    group.add(cube);
    group.scale.set(0.2, 0.2, 0.2);
    return group;
  }
  // H·ªá t·ªça ƒë·ªô c·ªßa file GTLF th√¨ tr·ª•c Y s·∫Ω h∆∞·ªõng l√™n tr√™n, tr·ª•c Z h∆∞·ªõng d·ªçc m√¥ h√¨nh
  const loader = new GLTFLoader();
  loader.load("test.glb", (gltf)=>{
    modelTemplate = gltf.scene;
    modelTemplate.scale.set(0.2,0.2,0.2);
    // Xoay t·ª´ h·ªá glTF (+Y up) sang h·ªá WebXR
    modelTemplate.rotation.x = Math.PI / 2;
    console.log(gltf.scene)
    console.log(gltf.parser)
    infoEl.textContent = "Model ƒë√£ load ‚Äî di chuy·ªÉn camera ƒë·ªÉ t√¨m m·∫∑t ph·∫≥ng ho·∫∑c marker.";
  }, undefined, (err)=>{
    console.error("GLTF load error:", err);
    infoEl.textContent = "L·ªói load GLTF ‚Äî t·∫°o model m·∫´u thay th·∫ø.";
    modelTemplate = createFallbackModel();
  });

  function cloneModel(template) {
    const clone = template.clone(true);
    clone.traverse((n)=>{
      if (n.isMesh && n.material) {
        n.material = n.material.clone();
        n.material.transparent = true;
        n.material.userData.__cloned = true;
      }
    });
    return clone;
  }

  function clearAllPlacementsAndAnchors() {
    if (allAnchors.size) {
      for (const a of allAnchors) { try { if (a.delete) a.delete(); } catch(e){} }
      allAnchors.clear();
    }
    while (PLACEMENTS_ROOT.children.length) {
      const child = PLACEMENTS_ROOT.children[0];
      PLACEMENTS_ROOT.remove(child);
    }
    currentAnchor = null;
    currentModel = null;
    controlPanel.style.display = 'none';
    adjustmentPanel.style.display = 'none';
    toggleAdjustPanel.style.display = 'none';
  }

  // H√†m ƒë·∫∑t m√¥ h√¨nh l√™n marker v·ªõi h∆∞·ªõng tr·ª•c X tr√πng v·ªõi ph√°p tuy·∫øn c·ªßa marker
  function placeModelOnMarker(pose) {
      if (!modelTemplate || isPlacing) return;
      
      isPlacing = true;
      clearAllPlacementsAndAnchors();
      
      const group = new THREE.Group();
      group.matrixAutoUpdate = false;
      
      // S·ª≠ d·ª•ng ma tr·∫≠n t·ª´ pose c·ªßa marker
      const matrix = new THREE.Matrix4().fromArray(pose.transform.matrix);
      const position = new THREE.Vector3();
      const quaternion = new THREE.Quaternion();
      const scale = new THREE.Vector3();
      matrix.decompose(position, quaternion, scale);
      
      // C√°c tr·ª•c trong h·ªá local c·ªßa marker
      const localX = new THREE.Vector3(1,0,0);
      const localY = new THREE.Vector3(0,1,0); // PH√ÅP TUY·∫æN marker
      const localZ = new THREE.Vector3(0,0,1);
      
      // ƒê∆∞a sang world
      const markerRight  = localX.clone().applyQuaternion(quaternion);
      const markerNormal = localY.clone().applyQuaternion(quaternion); // ph√°p tuy·∫øn m·∫∑t
      const markerUp = localZ.clone().applyQuaternion(quaternion);
      
      let modelXAxis = markerNormal.clone().negate();   // +X model = v√†o trong marker
      let modelYAxis = markerRight.clone().negate();    // +Y model = sang tr√°i
      let modelZAxis = markerUp.clone().negate();       // +Z model = l√™n tr√™n
      
      // B·∫£o ƒë·∫£m tr·ª±c giao/chu·∫©n ho√°
      modelXAxis.normalize();
      modelZAxis.normalize();
      modelYAxis.copy(new THREE.Vector3().crossVectors(modelZAxis, modelXAxis)).normalize();
      
      // T·∫°o ma tr·∫≠n bi·∫øn ƒë·ªïi
      const modelMatrix = new THREE.Matrix4().makeBasis(modelXAxis, modelYAxis, modelZAxis);
      modelMatrix.setPosition(position);
      
      // √Åp d·ª•ng ma tr·∫≠n cho group
      group.matrix.copy(modelMatrix);
      
      PLACEMENTS_ROOT.add(group);
      
      const placed = cloneModel(modelTemplate);
      group.add(placed);
      currentModel = placed;
      
      // L∆∞u v·ªã tr√≠ v√† xoay ban ƒë·∫ßu ƒë·ªÉ reset
      originalModelPosition.copy(position);
      originalModelRotation.copy(group.rotation);
      originalModelScale.copy(group.scale);
      
      // T·∫°o anchor n·∫øu c√≥ th·ªÉ
      if (pose && pose.createAnchor) {
        pose.createAnchor().then(anchor => {
          currentAnchor = { anchor, group };
          allAnchors.add(anchor);
        }).catch(console.error);
      }
      
      infoEl.textContent = "Model ƒë√£ ƒë∆∞·ª£c ƒë·∫∑t tr√™n marker! Tr·ª•c X v√†o marker, Y sang tr√°i, Z l√™n tr√™n.";
      isPlacing = false;
      markerDetected = false;
      
      // ·∫®n hi·ªáu ·ª©ng qu√©t sau khi ƒë·∫∑t model
      hideQRFrame();
      
      // Hi·ªÉn th·ªã panel ƒëi·ªÅu khi·ªÉn
      controlPanel.style.display = 'flex';
      toggleAdjustPanel.style.display = 'block';
      
      // Debug: hi·ªÉn th·ªã c√°c tr·ª•c c·ªßa marker
      debugAxes(group, modelXAxis, modelYAxis, modelZAxis);
  }

  // H√†m debug ƒë·ªÉ hi·ªÉn th·ªã c√°c tr·ª•c
  function debugAxes(group, xAxis, yAxis, zAxis) {
      const axisLength = 0.2;
      
      // Tr·ª•c X (ƒë·ªè) - h∆∞·ªõng v√†o marker
      const xGeometry = new THREE.BufferGeometry().setFromPoints([
          new THREE.Vector3(0, 0, 0),
          new THREE.Vector3(axisLength, 0, 0,)
      ]);
      const xMaterial = new THREE.LineBasicMaterial({ color: 0xff0000 });
      const xAxisLine = new THREE.Line(xGeometry, xMaterial);
      group.add(xAxisLine);
      
      // Tr·ª•c Y (xanh l√°) - h∆∞·ªõng sang tr√°i
      const yGeometry = new THREE.BufferGeometry().setFromPoints([
          new THREE.Vector3(0, 0, 0),
          new THREE.Vector3(0, axisLength, 0)
      ]);
      const yMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00 });
      const yAxisLine = new THREE.Line(yGeometry, yMaterial);
      group.add(yAxisLine);
      
      // Tr·ª•c Z (xanh d∆∞∆°ng) - h∆∞·ªõng l√™n tr√™n
      const zGeometry = new THREE.BufferGeometry().setFromPoints([
          new THREE.Vector3(0, 0, 0),
          new THREE.Vector3(0, 0, axisLength)
      ]);
      const zMaterial = new THREE.LineBasicMaterial({ color: 0x0000ff });
      const zAxisLine = new THREE.Line(zGeometry, zMaterial);
      group.add(zAxisLine);
  }
    
  // --- orientation helpers ---
  let _lastHDir = new THREE.Vector3(1, 0, 0);
  function getCameraHorizontalDir() {
    const fwd = new THREE.Vector3();
    camera.getWorldDirection(fwd);
    fwd.y = 0;
    const len = fwd.length();
    if (len < 1e-3) return _lastHDir.clone();
    fwd.divideScalar(len);
    _lastHDir.copy(fwd);
    return fwd;
  }

  function computePlacementMatrixFromMatrix(baseMatrix) {
    const poseMat = new THREE.Matrix4().copy(baseMatrix);

    // L·∫•y normal t·ª´ m·∫∑t ph·∫≥ng (gi·ªØ l√† "up")
    const rotMat = new THREE.Matrix4().extractRotation(poseMat);
    const normal = new THREE.Vector3(0,1,0).applyMatrix4(rotMat).normalize();

    // L·∫•y h∆∞·ªõng forward theo camera (x-axis theo ƒë·ªãnh nghƒ©a c·ªßa b·∫°n)
    const camFwd = getCameraHorizontalDir();

    // Chi·∫øu forward l√™n m·∫∑t ph·∫≥ng
    const camProj = camFwd.clone().projectOnPlane(normal);
    if (camProj.length() < 1e-3) {
      camProj.copy(_lastHDir).projectOnPlane(normal);
      if (camProj.length() < 1e-3) camProj.set(1,0,0);
    }
    camProj.normalize();

    // ƒê·∫∑t tr·ª•c theo quy ∆∞·ªõc m·ªõi
    const xAxis = camProj.clone();                   // X = ra kh·ªèi camera
    const zAxis = normal.clone().normalize();        // Z = l√™n tr√™n
    const yAxis = new THREE.Vector3().crossVectors(zAxis, xAxis).normalize(); 
    // Y = tr√°i (cross theo Z √ó X)

    // T·∫°o h·ªá c∆° s·ªü
    const basis = new THREE.Matrix4().makeBasis(xAxis, yAxis, zAxis);

    // ƒê·∫∑t v·ªã tr√≠
    const pos = new THREE.Vector3().setFromMatrixPosition(poseMat);
    basis.setPosition(pos);

    return basis;
  }

  async function placeAnchorFromLastHit() {
    if (isPlacing) return;
    isPlacing = true;
    const hit = lastHitResult;
    const refSpace = renderer.xr.getReferenceSpace();
    if (!hit || !refSpace || !modelTemplate) { isPlacing=false; return; }
    clearAllPlacementsAndAnchors();
    const pose = hit.getPose(refSpace);
    const anchor = await hit.createAnchor?.(refSpace).catch(()=>null);
    const group = new THREE.Group();
    group.matrixAutoUpdate=false;
    if (pose) {
      // d√πng orientation helper ƒë·ªÉ ƒë·∫∑t matrix
      const placementMatrix = computePlacementMatrixFromMatrix(new THREE.Matrix4().fromArray(pose.transform.matrix));
      group.matrix.copy(placementMatrix);
      
      // L∆∞u v·ªã tr√≠ v√† xoay ban ƒë·∫ßu ƒë·ªÉ reset
      group.matrix.decompose(originalModelPosition, originalModelRotation, originalModelScale);
    }
    PLACEMENTS_ROOT.add(group);
    const placed = cloneModel(modelTemplate);
    group.add(placed);
    currentModel = placed;
    currentAnchor = { anchor, group };
    if (anchor) allAnchors.add(anchor);
    
    // Hi·ªÉn th·ªã panel ƒëi·ªÅu khi·ªÉn
    controlPanel.style.display = 'flex';
    toggleAdjustPanel.style.display = 'block';
    
    isPlacing=false;
  }

  const controller = renderer.xr.getController(0);
  controller.addEventListener("select", ()=>{ if (reticle.visible) placeAnchorFromLastHit(); });
  scene.add(controller);
  
  window.addEventListener("click", ()=>{ 
    const s=renderer.xr.getSession(); 
    if (s && reticle.visible) placeAnchorFromLastHit(); 
  });

  placementBtn.addEventListener("click", ()=>{
    if (markerPose) {
      placeModelOnMarker(markerPose);
      placementBtn.style.display = 'none';
    }
  });

  document.getElementById("opacityControl").addEventListener("input",(e)=>{
    const v = parseFloat(e.target.value);
    if (currentModel) {
      currentModel.traverse((n)=>{ if (n.isMesh && n.material) n.material.opacity=v; });
    }
  });

  resetBtn.addEventListener("click",()=>{ 
    const s=renderer.xr.getSession(); 
    if (s) s.end(); 
    hideQRFrame();
  });
    
  // T·∫°o v√≤ng tr√≤n focus ·ªü gi·ªØa m√†n h√¨nh (ch·ªâ ƒë·ªÉ ng∆∞·ªùi d√πng th·∫•y)
  const focusRing = document.createElement("div");
  focusRing.style.position = "absolute";
  focusRing.style.top = "50%";
  focusRing.style.left = "50%";
  focusRing.style.width = "30px";
  focusRing.style.height = "30px";
  focusRing.style.border = "2px solid white";
  focusRing.style.borderRadius = "50%";
  focusRing.style.transform = "translate(-50%, -50%)";
  focusRing.style.pointerEvents = "none";
  document.body.appendChild(focusRing);
  
  // Raycaster v√† vector chu·∫©n h√≥a t√¢m m√†n h√¨nh
  const raycaster = new THREE.Raycaster();
  const center = new THREE.Vector2(0, 0); 
  function getIntersects() {
    const offsets = [
      new THREE.Vector2(0, 0),              // tia trung t√¢m
      new THREE.Vector2(0.01, 0),           // l·ªách ph·∫£i
      new THREE.Vector2(-0.01, 0),          // l·ªách tr√°i
      new THREE.Vector2(0, 0.01),           // l·ªách l√™n
      new THREE.Vector2(0, -0.01)           // l·ªách xu·ªëng
    ];
    let allHits = [];
    offsets.forEach(off => {
      const ndc = new THREE.Vector2(center.x + off.x, center.y + off.y);
      raycaster.setFromCamera(ndc, camera);
      const hits = raycaster.intersectObjects(scene.children, true);
      if (hits.length > 0) allHits.push(hits[0]);
    });
  
    // ch·ªçn object g·∫ßn nh·∫•t trong t·∫•t c·∫£ c√°c tia
    if (allHits.length > 0) {
      allHits.sort((a, b) => a.distance - b.distance);
      return allHits[0];
    }
    return null;
  }
    
  // S·ª± ki·ªán b·∫Øt ƒë·∫ßu v√†o ch·∫ø ƒë·ªô AR  
  renderer.xr.addEventListener("sessionstart", async ()=>{
    const session = renderer.xr.getSession();
    infoEl.textContent = "ƒê√£ v√†o ch·∫ø ƒë·ªô AR, di chuy·ªÉn ƒë·ªÉ qu√©t m·∫∑t ph·∫≥ng ho·∫∑c marker...";
    const viewerSpace = await session.requestReferenceSpace("viewer");
    hitTestSource = await session.requestHitTestSource({ space: viewerSpace }).catch(()=>null);
    
    session.addEventListener("end", ()=>{ 
      hitTestSource = null; 
      clearAllPlacementsAndAnchors(); 
      infoEl.textContent = "AR session ƒë√£ k·∫øt th√∫c.";
      markerStatusEl.textContent = "Ch∆∞a ph√°t hi·ªán marker";
      placementBtn.style.display = 'none';
      markerDetected = false;
      hideQRFrame();
    });
  });

  // C√°c h√†m m·ªõi ƒë·ªÉ ƒëi·ªÅu ch·ªânh v·ªã tr√≠ v√† xoay m√¥ h√¨nh
  function moveModel(direction, amount = 0.01) {
    if (!currentModel || !currentModel.parent) return;
    
    const group = currentModel.parent;
    const worldPos = new THREE.Vector3();
    group.getWorldPosition(worldPos);
    
    let moveVector = new THREE.Vector3();
    
    switch(direction) {
      case 'forward':
        // Di chuy·ªÉn theo h∆∞·ªõng camera (tr√™n m·∫∑t ph·∫≥ng XZ)
        const camForward = new THREE.Vector3();
        camera.getWorldDirection(camForward);
        camForward.y = 0;
        camForward.normalize();
        moveVector = camForward.multiplyScalar(amount);
        break;
      case 'backward':
        const camBackward = new THREE.Vector3();
        camera.getWorldDirection(camBackward);
        camBackward.y = 0;
        camBackward.normalize();
        moveVector = camBackward.multiplyScalar(-amount);
        break;
      case 'left':
        // Di chuy·ªÉn sang tr√°i so v·ªõi camera
        const camLeft = new THREE.Vector3();
        camera.getWorldDirection(camLeft);
        camLeft.y = 0;
        camLeft.normalize();
        camLeft.cross(new THREE.Vector3(0, 1, 0));
        moveVector = camLeft.multiplyScalar(amount);
        break;
      case 'right':
        const camRight = new THREE.Vector3();
        camera.getWorldDirection(camRight);
        camRight.y = 0;
        camRight.normalize();
        camRight.cross(new THREE.Vector3(0, -1, 0));
        moveVector = camRight.multiplyScalar(amount);
        break;
    }
    
    group.position.add(moveVector);
    
    // C·∫≠p nh·∫≠t matrix
    group.matrix.compose(group.position, group.quaternion, group.scale);
  }

  function adjustModelHeight(value) {
    if (!currentModel || !currentModel.parent) return;
    
    const group = currentModel.parent;
    group.position.y = parseFloat(value);
    
    // C·∫≠p nh·∫≠t matrix
    group.matrix.compose(group.position, group.quaternion, group.scale);
    
    // C·∫≠p nh·∫≠t gi√° tr·ªã hi·ªÉn th·ªã
    document.getElementById('heightValue').textContent = value.toFixed(2);
  }

  function rotateModel(angle) {
    if (!currentModel || !currentModel.parent) return;
    
    const group = currentModel.parent;
    group.rotation.y = THREE.MathUtils.degToRad(angle);
    
    // C·∫≠p nh·∫≠t matrix
    group.matrix.compose(group.position, group.quaternion, group.scale);
    
    // C·∫≠p nh·∫≠t gi√° tr·ªã hi·ªÉn th·ªã
    document.getElementById('rotationValue').textContent = angle;
  }

  function resetModelPosition() {
    if (!currentModel || !currentModel.parent) return;
    
    const group = currentModel.parent;
    group.position.copy(originalModelPosition);
    group.rotation.copy(originalModelRotation);
    group.scale.copy(originalModelScale);
    
    // C·∫≠p nh·∫≠t matrix
    group.matrix.compose(group.position, group.quaternion, group.scale);
    
    // Reset c√°c thanh tr∆∞·ª£t
    document.getElementById('heightSlider').value = 0;
    document.getElementById('heightValue').textContent = '0.00';
    document.getElementById('rotationSlider').value = 0;
    document.getElementById('rotationValue').textContent = '0';
  }

  function toggleModelVisibility() {
    if (!currentModel) return;
    
    currentModel.visible = !currentModel.visible;
    toggleVisibilityBtn.textContent = currentModel.visible ? 'üëÅÔ∏è' : 'üö´';
  }

  // Thi·∫øt l·∫≠p s·ª± ki·ªán cho c√°c n√∫t ƒëi·ªÅu khi·ªÉn m·ªõi
  document.getElementById('moveForward').addEventListener('click', () => moveModel('forward'));
  document.getElementById('moveBackward').addEventListener('click', () => moveModel('backward'));
  document.getElementById('moveLeft').addEventListener('click', () => moveModel('left'));
  document.getElementById('moveRight').addEventListener('click', () => moveModel('right'));
  
  document.getElementById('heightSlider').addEventListener('input', (e) => {
    adjustModelHeight(parseFloat(e.target.value));
  });
  
  document.getElementById('rotationSlider').addEventListener('input', (e) => {
    rotateModel(parseInt(e.target.value));
  });
  
  toggleVisibilityBtn.addEventListener('click', toggleModelVisibility);
  
  adjustPositionBtn.addEventListener('click', () => {
    adjustmentPanel.style.display = 'flex';
    isAdjustmentMode = true;
  });
  
  closeAdjustPanel.addEventListener('click', () => {
    adjustmentPanel.style.display = 'none';
    isAdjustmentMode = false;
  });
  
  resetPositionBtn.addEventListener('click', resetModelPosition);
  
  toggleAdjustPanel.addEventListener('click', () => {
    if (adjustmentPanel.style.display === 'flex') {
      adjustmentPanel.style.display = 'none';
      isAdjustmentMode = false;
    } else {
      adjustmentPanel.style.display = 'flex';
      isAdjustmentMode = true;
    }
  });

  // V√≤ng l·∫∑p render ch√≠nh
  renderer.setAnimationLoop((t,frame)=>{
    if (frame) {
      const refSpace = renderer.xr.getReferenceSpace();
      if (hitTestSource && refSpace) {
        const hits = frame.getHitTestResults(hitTestSource);
        if (hits.length>0) {
          lastHitResult = hits[0];
          const pose = hits[0].getPose(refSpace);
          if (pose) { reticle.visible=true; reticle.matrix.fromArray(pose.transform.matrix); }
        } else { reticle.visible=false; }
      }

      // Ki·ªÉm tra marker tracking
      if (frame.trackedAnchors) {
        for (const anchor of frame.trackedAnchors.values()) {
          if (anchor.trackableType === 'image') {
            const pose = frame.getPose(anchor.anchorSpace, refSpace);
            if (pose) {
              markerPose = pose;
              markerDetected = true;
              markerStatusEl.textContent = "ƒê√£ ph√°t hi·ªán marker";
              updateQRFramePosition(pose);
              
              // Hi·ªÉn th·ªã n√∫t ƒë·∫∑t m√¥ h√¨nh n·∫øu ch∆∞a c√≥ m√¥ h√¨nh n√†o
              if (!currentModel) {
                placementBtn.style.display = 'block';
              }
            }
          }
        }
      } else if (!markerDetected) {
        markerStatusEl.textContent = "Ch∆∞a ph√°t hi·ªán marker";
        hideQRFrame();
        placementBtn.style.display = 'none';
      }
    }
  });
  </script>
</body>
</html>
