<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <title>WebXR AR với Marker Tracking và Hiệu Ứng Quét</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
    #opacityControl {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10;
    }
    #info {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 10;
      background: rgba(0,0,0,0.4);
      color: white;
      padding: 6px 8px;
      font-family: monospace;
      font-size: 13px;
      border-radius: 6px;
      white-space: pre-line;
      max-width: 80%;
    }
    #resetBtn {
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 10;
      background: rgba(255,255,255,0.9);
      color: #111;
      padding: 6px 10px;
      font-family: system-ui, sans-serif;
      font-size: 13px;
      border: 1px solid #ccc;
      border-radius: 6px;
      cursor: pointer;
    }
    #markerStatus {
      position: absolute;
      bottom: 60px;
      left: 10px;
      z-index: 10;
      background: rgba(0,0,0,0.4);
      color: white;
      padding: 6px 8px;
      font-family: monospace;
      font-size: 13px;
      border-radius: 6px;
    }
    #placementBtn {
      position: absolute;
      bottom: 100px;
      right: 10px;
      z-index: 10;
      background: rgba(255,255,255,0.9);
      color: #111;
      padding: 8px 12px;
      font-family: system-ui, sans-serif;
      font-size: 13px;
      border: 1px solid #ccc;
      border-radius: 6px;
      cursor: pointer;
      display: none;
    }
    /* Hiệu ứng quét QR code */
    #markerOverlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 5;
      display: none;
    }
    .qr-frame {
      position: absolute;
      border: 4px solid transparent;
      border-radius: 12px;
      box-shadow: 0 0 20px rgba(255, 255, 0, 0.7);
      animation: pulse 1.5s infinite alternate;
    }
    .qr-corner {
      position: absolute;
      width: 20px;
      height: 20px;
      border: 4px solid #ff0;
    }
    .qr-corner-tl {
      top: -4px;
      left: -4px;
      border-right: none;
      border-bottom: none;
      border-top-left-radius: 8px;
    }
    .qr-corner-tr {
      top: -4px;
      right: -4px;
      border-left: none;
      border-bottom: none;
      border-top-right-radius: 8px;
    }
    .qr-corner-bl {
      bottom: -4px;
      left: -4px;
      border-right: none;
      border-top: none;
      border-bottom-left-radius: 8px;
    }
    .qr-corner-br {
      bottom: -4px;
      right: -4px;
      border-left: none;
      border-top: none;
      border-bottom-right-radius: 8px;
    }
    .scan-line {
      position: absolute;
      height: 3px;
      width: 100%;
      background: linear-gradient(to right, transparent, #ff0, transparent);
      top: 50%;
      animation: scan 2s linear infinite;
    }
    @keyframes pulse {
      0% { box-shadow: 0 0 10px rgba(255, 255, 0, 0.5); }
      100% { box-shadow: 0 0 30px rgba(255, 255, 0, 1); }
    }
    @keyframes scan {
      0% { top: 0%; opacity: 0; }
      10% { opacity: 1; }
      90% { opacity: 1; }
      100% { top: 100%; opacity: 0; }
    }
    
    /* UI điều chỉnh vị trí và hướng */
    #adjustmentUI {
      position: absolute;
      right: 10px;
      top: 50%;
      transform: translateY(-50%);
      z-index: 10;
      background: rgba(0,0,0,0.6);
      padding: 10px;
      border-radius: 8px;
      display: none;
      flex-direction: column;
      gap: 10px;
    }
    .adjustment-control {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 5px;
    }
    .adjustment-control label {
      color: white;
      font-size: 12px;
    }
    .adjustment-control input[type="range"] {
      width: 100px;
    }
    .arrow-control {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 5px;
      margin: 10px 0;
    }
    .arrow-btn {
      width: 40px;
      height: 40px;
      background: rgba(255,255,255,0.8);
      border: 1px solid #ccc;
      border-radius: 50%;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 20px;
      cursor: pointer;
      user-select: none;
    }
    .arrow-row {
      display: flex;
      gap: 10px;
    }
    #toggleUI {
      position: absolute;
      right: 10px;
      top: 60px;
      z-index: 11;
      background: rgba(255,255,255,0.9);
      color: #111;
      padding: 6px 10px;
      font-family: system-ui, sans-serif;
      font-size: 13px;
      border: 1px solid #ccc;
      border-radius: 6px;
      cursor: pointer;
      display: none;
    }
    #visibilityToggle {
      position: absolute;
      right: 10px;
      top: 100px;
      z-index: 11;
      background: rgba(255,255,255,0.9);
      color: #111;
      padding: 6px 10px;
      font-family: system-ui, sans-serif;
      font-size: 13px;
      border: 1px solid #ccc;
      border-radius: 6px;
      cursor: pointer;
      display: none;
    }
  </style>
</head>
<body>
  <div id="info">Đang chờ khởi động AR...</div>
  <div id="markerStatus">Chưa phát hiện marker</div>
  <button id="resetBtn" type="button">Reset AR</button>
  <button id="placementBtn" type="button">Đặt mô hình</button>
  <button id="toggleUI" type="button">Hiện điều chỉnh</button>
  <button id="visibilityToggle" type="button">Ẩn mô hình</button>
  
  <!-- Overlay hiệu ứng quét QR code -->
  <div id="markerOverlay">
    <div class="qr-frame">
      <div class="qr-corner qr-corner-tl"></div>
      <div class="qr-corner qr-corner-tr"></div>
      <div class="qr-corner qr-corner-bl"></div>
      <div class="qr-corner qr-corner-br"></div>
      <div class="scan-line"></div>
    </div>
  </div>

  <!-- UI điều chỉnh vị trí và hướng -->
  <div id="adjustmentUI">
    <div class="arrow-control">
      <div class="arrow-row">
        <div class="arrow-btn" id="moveLeft">←</div>
        <div class="arrow-btn" id="moveRight">→</div>
      </div>
      <div class="arrow-row">
        <div class="arrow-btn" id="moveForward">↑</div>
        <div class="arrow-btn" id="moveBackward">↓</div>
      </div>
    </div>
    
    <div class="adjustment-control">
      <label for="heightSlider">Độ cao</label>
      <input type="range" id="heightSlider" min="-1" max="1" step="0.01" value="0">
    </div>
    
    <div class="adjustment-control">
      <label for="rotationSlider">Xoay ngang</label>
      <input type="range" id="rotationSlider" min="-3.14" max="3.14" step="0.01" value="0">
    </div>
    
    <div class="adjustment-control">
      <label for="opacitySlider">Độ trong suốt</label>
      <input type="range" id="opacitySlider" min="0" max="1" step="0.05" value="1">
    </div>
  </div>

  <script type="module">
  import * as THREE from "https://esm.sh/three@0.160.0";
  import { GLTFLoader } from "https://esm.sh/three@0.160.0/examples/jsm/loaders/GLTFLoader.js";
  import { ARButton } from "https://esm.sh/three@0.160.0/examples/jsm/webxr/ARButton.js";

  const infoEl = document.getElementById("info");
  const markerStatusEl = document.getElementById("markerStatus");
  const resetBtn = document.getElementById("resetBtn");
  const placementBtn = document.getElementById("placementBtn");
  const markerOverlay = document.getElementById("markerOverlay");
  const qrFrame = document.querySelector('.qr-frame');
  const toggleUI = document.getElementById('toggleUI');
  const visibilityToggle = document.getElementById('visibilityToggle');
  const adjustmentUI = document.getElementById('adjustmentUI');
  const heightSlider = document.getElementById('heightSlider');
  const rotationSlider = document.getElementById('rotationSlider');
  const opacitySlider = document.getElementById('opacitySlider');

  let modelTemplate = null;
  let currentAnchor = null;
  let reticle;
  let hitTestSource = null;
  let lastHitResult = null;
  let currentModel = null;
  let isDragging = false;
  let previousTouchX = 0;
  let isPlacing = false;
  let markerDetected = false;
  let markerPose = null;
  const allAnchors = new Set();
  
  // Biến lưu trữ reference space
  let viewerReferenceSpace = null;
  
  // Biến lưu trữ thông tin điều chỉnh
  let adjustmentData = {
    positionOffset: new THREE.Vector3(0, 0, 0),
    rotation: 0,
    height: 0,
    visible: true
  };

  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.01, 20);
  const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.xr.enabled = true;
  document.body.appendChild(renderer.domElement);

  const PLACEMENTS_ROOT = new THREE.Group();
  scene.add(PLACEMENTS_ROOT);

  // Hàm cập nhật vị trí và kích thước của hiệu ứng quét QR dựa trên vị trí marker
  function updateQRFramePosition(pose) {
    if (!pose) return;
    
    // Lấy ma trận chuyển đổi từ pose
    const matrix = new THREE.Matrix4().fromArray(pose.transform.matrix);
    const position = new THREE.Vector3();
    const scale = new THREE.Vector3();
    const quaternion = new THREE.Quaternion();
    matrix.decompose(position, quaternion, scale);
    
    // Chuyển đổi vị trí 3D sang tọa độ màn hình 2D
    const vector = position.clone();
    vector.project(camera);
    
    const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
    const y = -(vector.y * 0.5 - 0.5) * window.innerHeight;
    
    // Ước tính kích thước của marker trên màn hình dựa trên khoảng cách
    const distance = position.distanceTo(camera.position);
    const markerSize = (0.15 / distance) * 500; // 0.15 là widthInMeters của marker
    
    // Cập nhật vị trí và kích thước của khung QR
    qrFrame.style.width = `${markerSize}px`;
    qrFrame.style.height = `${markerSize}px`;
    qrFrame.style.left = `${x - markerSize/2}px`;
    qrFrame.style.top = `${y - markerSize/2}px`;
    
    // Hiển thị overlay
    markerOverlay.style.display = 'block';
  }

  // Ẩn hiệu ứng quét QR
  function hideQRFrame() {
    markerOverlay.style.display = 'none';
  }

  // Cập nhật vị trí và hướng của mô hình dựa trên điều chỉnh
  function updateModelTransform() {
    if (!currentModel) return;
    
    const group = currentModel.parent;
    if (!group) return;
    
    // Lấy ma trận gốc từ marker
    const matrix = new THREE.Matrix4().fromArray(markerPose.transform.matrix);
    const position = new THREE.Vector3();
    const quaternion = new THREE.Quaternion();
    const scale = new THREE.Vector3();
    matrix.decompose(position, quaternion, scale);
    
    // Xác định các trục cơ sở của marker
    const markerNormal = new THREE.Vector3(0, 0, 1).applyQuaternion(quaternion);
    const markerUp = new THREE.Vector3(0, 1, 0).applyQuaternion(quaternion);
    const markerRight = new THREE.Vector3(1, 0, 0).applyQuaternion(quaternion);
    
    // Điều chỉnh hướng trục theo yêu cầu
    const inwardNormal = new THREE.Vector3().copy(markerNormal).negate();
    const leftDirection = new THREE.Vector3().copy(markerRight).negate();
    const upwardDirection = new THREE.Vector3().copy(markerUp);
    
    // Tạo ma trận biến đổi cơ sở
    const modelMatrix = new THREE.Matrix4();
    modelMatrix.set(
        inwardNormal.x, leftDirection.x, upwardDirection.x, position.x,
        inwardNormal.y, leftDirection.y, upwardDirection.y, position.y,
        inwardNormal.z, leftDirection.z, upwardDirection.z, position.z,
        0, 0, 0, 1
    );
    
    // Áp dụng các điều chỉnh từ UI
    const adjustmentMatrix = new THREE.Matrix4();
    
    // Xoay quanh trục Z (trục lên trên)
    const rotationQuaternion = new THREE.Quaternion();
    rotationQuaternion.setFromAxisAngle(upwardDirection, adjustmentData.rotation);
    
    // Dịch chuyển theo các trục
    const adjustedPosition = new THREE.Vector3(
        position.x + adjustmentData.positionOffset.x * leftDirection.x + 
                   adjustmentData.positionOffset.y * inwardNormal.x +
                   adjustmentData.positionOffset.z * upwardDirection.x,
        position.y + adjustmentData.positionOffset.x * leftDirection.y + 
                   adjustmentData.positionOffset.y * inwardNormal.y +
                   adjustmentData.positionOffset.z * upwardDirection.y,
        position.z + adjustmentData.positionOffset.x * leftDirection.z + 
                   adjustmentData.positionOffset.y * inwardNormal.z +
                   adjustmentData.positionOffset.z * upwardDirection.z
    );
    
    // Kết hợp các phép biến đổi
    adjustmentMatrix.compose(adjustedPosition, rotationQuaternion, new THREE.Vector3(1, 1, 1));
    
    // Áp dụng ma trận cho group
    group.matrix.copy(adjustmentMatrix);
    
    // Cập nhật độ trong suốt
    currentModel.traverse((n) => {
      if (n.isMesh && n.material) {
        n.material.opacity = adjustmentData.visible ? parseFloat(opacitySlider.value) : 0;
      }
    });
  }

  async function initARButton() {
    if (!("xr" in navigator)) { infoEl.textContent = "Trình duyệt không hỗ trợ WebXR."; return; }
    const supported = await navigator.xr.isSessionSupported("immersive-ar");
    if (!supported) { infoEl.textContent = "Thiết bị không hỗ trợ AR."; return; }
    // Load marker image
    try {
      const imgBitmap = await fetch("marker.png")
        .then(r => r.blob())
        .then(b => createImageBitmap(b));
      
      document.body.appendChild(ARButton.createButton(renderer, {
        requiredFeatures: ["image-tracking"],
        trackedImages: [
          {
            image: imgBitmap,
            widthInMeters: 0.15
          }
        ],
        optionalFeatures: ["hit-test", "anchors", "dom-overlay"],
        domOverlay: { root: document.body }
      }));
    } catch (e) {
      console.error("Lỗi khi tải marker:", e);
      infoEl.textContent = "Lỗi khi tải marker.png - vui lòng kiểm tra file và console";
    }
  }
  initARButton();

  scene.add(new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1));

  const ringGeo = new THREE.RingGeometry(0.08,0.1,32).rotateX(-Math.PI/2);
  const ringMat = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
  reticle = new THREE.Mesh(ringGeo, ringMat);
  reticle.matrixAutoUpdate = false;
  reticle.visible = false;
  scene.add(reticle);

  // Tạo hình khối mẫu nếu không tải được GLTF
  function createFallbackModel() {
    const geometry = new THREE.BoxGeometry(0.1, 0.1, 0.1);
    const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
    const cube = new THREE.Mesh(geometry, material);
    const group = new THREE.Group();
    group.add(cube);
    group.scale.set(0.2, 0.2, 0.2);
    return group;
  }

  const loader = new GLTFLoader();
  loader.load("test.glb", (gltf)=>{
    modelTemplate = gltf.scene;
    modelTemplate.scale.set(0.2,0.2,0.2);
    infoEl.textContent = "Model đã load — di chuyển camera để tìm mặt phẳng hoặc marker.";
  }, undefined, (err)=>{
    console.error("GLTF load error:", err);
    infoEl.textContent = "Lỗi load GLTF — tạo model mẫu thay thế.";
    modelTemplate = createFallbackModel();
  });

  function cloneModel(template) {
    const clone = template.clone(true);
    clone.traverse((n)=>{
      if (n.isMesh && n.material) {
        n.material = n.material.clone();
        n.material.transparent = true;
        n.material.userData.__cloned = true;
      }
    });
    return clone;
  }

  function clearAllPlacementsAndAnchors() {
    if (allAnchors.size) {
      for (const a of allAnchors) { try { if (a.delete) a.delete(); } catch(e){} }
      allAnchors.clear();
    }
    while (PLACEMENTS_ROOT.children.length) {
      const child = PLACEMENTS_ROOT.children[0];
      PLACEMENTS_ROOT.remove(child);
    }
    currentAnchor = null;
    currentModel = null;
  }

  // Hàm đặt mô hình lên marker
  function placeModelOnMarker(pose) {
    if (!modelTemplate || isPlacing) return;
    
    isPlacing = true;
    clearAllPlacementsAndAnchors();
    
    const group = new THREE.Group();
    group.matrixAutoUpdate = false;
    
    // Lưu trữ pose của marker
    markerPose = pose;
    
    // Đặt mô hình ban đầu
    updateModelTransform();
    
    PLACEMENTS_ROOT.add(group);
    
    const placed = cloneModel(modelTemplate);
    group.add(placed);
    currentModel = placed;
    
    // Tạo anchor nếu có thể
    if (pose && pose.createAnchor) {
      pose.createAnchor().then(anchor => {
        currentAnchor = { anchor, group };
        allAnchors.add(anchor);
      }).catch(console.error);
    }
    
    infoEl.textContent = "Model đã được đặt trên marker! Sử dụng UI bên phải để điều chỉnh.";
    isPlacing = false;
    markerDetected = false;
    
    // Hiển thị UI điều chỉnh
    toggleUI.style.display = 'block';
    visibilityToggle.style.display = 'block';
    
    // Ẩn hiệu ứng quét sau khi đặt model
    hideQRFrame();
  }

  // Xử lý sự kiện cho các nút điều khiển
  document.getElementById('moveLeft').addEventListener('click', () => {
    adjustmentData.positionOffset.x -= 0.05;
    updateModelTransform();
  });
  
  document.getElementById('moveRight').addEventListener('click', () => {
    adjustmentData.positionOffset.x += 0.05;
    updateModelTransform();
  });
  
  document.getElementById('moveForward').addEventListener('click', () => {
    adjustmentData.positionOffset.y += 0.05;
    updateModelTransform();
  });
  
  document.getElementById('moveBackward').addEventListener('click', () => {
    adjustmentData.positionOffset.y -= 0.05;
    updateModelTransform();
  });
  
  heightSlider.addEventListener('input', () => {
    adjustmentData.positionOffset.z = parseFloat(heightSlider.value);
    updateModelTransform();
  });
  
  rotationSlider.addEventListener('input', () => {
    adjustmentData.rotation = parseFloat(rotationSlider.value);
    updateModelTransform();
  });
  
  opacitySlider.addEventListener('input', () => {
    if (currentModel) {
      currentModel.traverse((n) => {
        if (n.isMesh && n.material) {
          n.material.opacity = parseFloat(opacitySlider.value);
        }
      });
    }
  });
  
  toggleUI.addEventListener('click', () => {
    adjustmentUI.style.display = adjustmentUI.style.display === 'none' ? 'flex' : 'none';
    toggleUI.textContent = adjustmentUI.style.display === 'none' ? 'Hiện điều chỉnh' : 'Ẩn điều chỉnh';
  });
  
  visibilityToggle.addEventListener('click', () => {
    adjustmentData.visible = !adjustmentData.visible;
    visibilityToggle.textContent = adjustmentData.visible ? 'Ẩn mô hình' : 'Hiện mô hình';
    
    if (currentModel) {
      currentModel.traverse((n) => {
        if (n.isMesh && n.material) {
          n.material.opacity = adjustmentData.visible ? parseFloat(opacitySlider.value) : 0;
        }
      });
    }
  });

  const controller = renderer.xr.getController(0);
  controller.addEventListener("select", ()=>{ if (reticle.visible) placeAnchorFromLastHit(); });
  scene.add(controller);
  
  window.addEventListener("click", ()=>{ 
    const s=renderer.xr.getSession(); 
    if (s && reticle.visible) placeAnchorFromLastHit(); 
  });

  placementBtn.addEventListener("click", ()=>{
    if (markerPose) {
      placeModelOnMarker(markerPose);
      placementBtn.style.display = 'none';
    }
  });

  resetBtn.addEventListener("click",()=>{ 
    const s=renderer.xr.getSession(); 
    if (s) s.end(); 
    hideQRFrame();
    toggleUI.style.display = 'none';
    visibilityToggle.style.display = 'none';
    adjustmentUI.style.display = 'none';
  });

  renderer.xr.addEventListener("sessionstart", async ()=>{
    const session = renderer.xr.getSession();
    infoEl.textContent = "Đã vào chế độ AR, di chuyển để quét mặt phẳng hoặc marker...";
    
    // Yêu cầu viewer reference space
    viewerReferenceSpace = await session.requestReferenceSpace("viewer");
    
    // Sử dụng viewer reference space cho hit test
    hitTestSource = await session.requestHitTestSource({ space: viewerReferenceSpace }).catch(()=>null);
    
    session.addEventListener("end", ()=>{ 
      hitTestSource = null; 
      clearAllPlacementsAndAnchors(); 
      infoEl.textContent = "AR session đã kết thúc.";
      markerStatusEl.textContent = "Chưa phát hiện marker";
      placementBtn.style.display = 'none';
      markerDetected = false;
      hideQRFrame();
      toggleUI.style.display = 'none';
      visibilityToggle.style.display = 'none';
      adjustmentUI.style.display = 'none';
      // Reset reference space
      viewerReferenceSpace = null;
    });
  });

  renderer.setAnimationLoop((t,frame)=>{
    if (frame) {
      if (hitTestSource && viewerReferenceSpace) {
        const hits = frame.getHitTestResults(hitTestSource);
        if (hits.length>0) {
          lastHitResult = hits[0];
          const pose = hits[0].getPose(viewerReferenceSpace);
          if (pose) { reticle.visible=true; reticle.matrix.fromArray(pose.transform.matrix); }
        } else { reticle.visible=false; }
      }
      
      // Xử lý image tracking - sử dụng viewer reference space
      const results = frame.getImageTrackingResults ? frame.getImageTrackingResults() : [];
      if (results.length > 0 && viewerReferenceSpace) {
        for (const result of results) {
          const state = result.trackingState;
          if (state === "tracked") {
            const pose = frame.getPose(result.imageSpace, viewerReferenceSpace);
            if (pose) {
              const p = pose.transform.position;
              markerStatusEl.textContent = 
                `Marker được nhận diện!\n`+
                `Vị trí: x=${p.x.toFixed(2)}, y=${p.y.toFixed(2)}, z=${p.z.toFixed(2)}`;
              
              // Cập nhật hiệu ứng quét QR tại vị trí marker
              updateQRFramePosition(pose);
              
              // Lưu trữ pose của marker để sử dụng sau
              markerPose = pose;
              
              // Tự động đặt model khi phát hiện marker
              if (!currentModel && modelTemplate && !markerDetected) {
                markerDetected = true;
                placementBtn.style.display = 'block';
                placementBtn.textContent = 'Đặt mô hình lên marker';
                
                // Tự động đặt mô hình sau 2 giây
                setTimeout(() => {
                  if (markerDetected && markerPose) {
                    placeModelOnMarker(markerPose);
                    placementBtn.style.display = 'none';
                  }
                }, 2000);
              }
            }
          } else {
            markerStatusEl.textContent = `Marker trạng thái: ${state}`;
            markerDetected = false;
            placementBtn.style.display = 'none';
            hideQRFrame();
          }
        }
      } else {
        markerStatusEl.textContent = "Chưa phát hiện marker";
        markerDetected = false;
        placementBtn.style.display = 'none';
        hideQRFrame();
      }
    }
    renderer.render(scene,camera);
  });

  window.addEventListener("resize",()=>{ 
    camera.aspect = window.innerWidth/window.innerHeight; 
    camera.updateProjectionMatrix(); 
    renderer.setSize(window.innerWidth, window.innerHeight); 
  });
  </script>
</body>
</html>
