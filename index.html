<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>WebXR AR Anchored Model — Fixed</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
    #opacityControl {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10;
    }
    #info {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 10;
      background: rgba(0,0,0,0.4);
      color: white;
      padding: 6px 8px;
      font-family: monospace;
      font-size: 13px;
      border-radius: 6px;
    }
    #resetBtn {
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 10;
      background: rgba(255,255,255,0.9);
      color: #111;
      padding: 6px 10px;
      font-family: system-ui, sans-serif;
      font-size: 13px;
      border-radius: 6px;
      border: 1px solid #ccc;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div id="info">Waiting for AR session...</div>
  <button id="resetBtn" type="button">Reset AR</button>
  <input type="range" id="opacityControl" min="0" max="1" step="0.05" value="1">

  <script type="module">
  import * as THREE from "https://esm.sh/three@0.160.0";
  import { GLTFLoader } from "https://esm.sh/three@0.160.0/examples/jsm/loaders/GLTFLoader.js";
  import { ARButton } from "https://esm.sh/three@0.160.0/examples/jsm/webxr/ARButton.js";

  const infoEl = document.getElementById('info');
  const resetBtn = document.getElementById('resetBtn');

  let modelTemplate = null;
  let currentAnchor = null;
  let reticle;
  let hitTestSource = null;
  let lastHitResult = null;
  let currentModel = null;
  let isDragging = false;
  let previousTouchX = 0;
  let isPlacing = false;
  const allAnchors = new Set();

  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);
  const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.xr.enabled = true;
  document.body.appendChild(renderer.domElement);

  // root for all placements so we can clear quickly
  const PLACEMENTS_ROOT = new THREE.Group();
  PLACEMENTS_ROOT.name = "PLACEMENTS_ROOT";
  scene.add(PLACEMENTS_ROOT);

  // Check WebXR support before creating ARButton
  async function initARButton() {
    if (!('xr' in navigator)) {
      infoEl.textContent = "WebXR not available in this browser.";
      return;
    }
    try {
      const supported = await navigator.xr.isSessionSupported('immersive-ar');
      if (!supported) {
        infoEl.textContent = "WebXR AR not supported on this device/browser.";
        return;
      }
      // create button with hit-test as OPTIONAL (so session can start even if device lacks hit-test)
      document.body.appendChild(ARButton.createButton(renderer, {
        requiredFeatures: [],
        optionalFeatures: ['hit-test', 'anchors', 'dom-overlay'],
        domOverlay: { root: document.body }
      }));
    } catch (e) {
      console.warn("isSessionSupported error:", e);
      infoEl.textContent = "Failed to query WebXR support.";
    }
  }
  initARButton();

  scene.add(new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1));

  // reticle
  const ringGeo = new THREE.RingGeometry(0.08, 0.1, 32).rotateX(-Math.PI / 2);
  const ringMat = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
  reticle = new THREE.Mesh(ringGeo, ringMat);
  reticle.matrixAutoUpdate = false;
  reticle.visible = false;
  scene.add(reticle);

  // load model (must be served via https or localhost)
  const loader = new GLTFLoader();
  loader.load("test.glb", (gltf) => {
    modelTemplate = gltf.scene;
    modelTemplate.scale.set(0.2, 0.2, 0.2);
    infoEl.textContent = "Model loaded — move device to see reticle.";
  }, undefined, (err) => {
    console.error("GLTF load error:", err);
    infoEl.textContent = "GLTF load error — check console.";
  });

  // clone: clone materials only (share geometry with template to avoid heavy memory ops)
  function cloneModel(template) {
    const clone = template.clone(true);
    clone.traverse((node) => {
      if (node.isMesh && node.material) {
        node.material = node.material.clone();
        node.material.transparent = true;
        node.material.userData.__cloned = true;
      }
    });
    return clone;
  }

  // orientation helpers
  let _lastHDir = new THREE.Vector3(1, 0, 0);
  function getCameraHorizontalDir() {
    const fwd = new THREE.Vector3();
    camera.getWorldDirection(fwd);
    fwd.y = 0;
    const len = fwd.length();
    if (len < 1e-3) return _lastHDir.clone();
    fwd.divideScalar(len);
    _lastHDir.copy(fwd);
    return fwd;
  }

  function computePlacementMatrixFromMatrix(baseMatrix) {
    const poseMat = new THREE.Matrix4().copy(baseMatrix);
    const rotMat = new THREE.Matrix4().extractRotation(poseMat);
    const normal = new THREE.Vector3(0,1,0).applyMatrix4(rotMat).normalize();
    const camH = getCameraHorizontalDir();
    const camProj = camH.clone().projectOnPlane(normal);
    if (camProj.length() < 1e-3) {
      camProj.copy(_lastHDir).projectOnPlane(normal);
      if (camProj.length() < 1e-3) camProj.set(1,0,0);
    }
    camProj.normalize();
    const xAxis = camProj.clone();
    const yAxis = normal.clone().normalize();
    const zAxis = new THREE.Vector3().crossVectors(yAxis, xAxis).normalize();
    const basis = new THREE.Matrix4().makeBasis(xAxis, yAxis, zAxis);
    const pos = new THREE.Vector3().setFromMatrixPosition(poseMat);
    basis.setPosition(pos);
    return basis;
  }

  // dispose only cloned materials (do NOT dispose shared geometry)
  function disposeMaterials(obj) {
    obj.traverse((child) => {
      if (child.isMesh) {
        const mat = child.material;
        if (Array.isArray(mat)) {
          mat.forEach(m => { if (m && m.userData && m.userData.__cloned) m.dispose(); });
        } else if (mat && mat.userData && mat.userData.__cloned) {
          mat.dispose();
        }
      }
    });
  }

  // clear placements and anchors fully
  function clearAllPlacementsAndAnchors() {
    // delete anchors
    if (allAnchors.size) {
      for (const a of allAnchors) {
        try {
          if (typeof a.delete === 'function') a.delete();
          else if (typeof a.detach === 'function') a.detach();
        } catch (e) { /* ignore */ }
      }
      allAnchors.clear();
    }
    // remove children from PLACEMENTS_ROOT
    while (PLACEMENTS_ROOT.children.length) {
      const child = PLACEMENTS_ROOT.children[0];
      disposeMaterials(child);
      PLACEMENTS_ROOT.remove(child);
    }
    currentAnchor = null;
    currentModel = null;
  }

  // place model (with reentrancy guard)
  async function placeAnchorFromLastHit() {
    if (isPlacing) return;
    isPlacing = true;

    const hit = lastHitResult;
    const referenceSpace = renderer.xr.getReferenceSpace();
    if (!hit || !referenceSpace || !modelTemplate) { isPlacing = false; return; }

    // clear all previous
    clearAllPlacementsAndAnchors();

    const pose = hit.getPose(referenceSpace);

    try {
      // try anchor first (but not required)
      const anchor = await hit.createAnchor(referenceSpace).catch(()=>null);

      if (anchor) {
        allAnchors.add(anchor);
        const anchorGroup = new THREE.Group();
        anchorGroup.matrixAutoUpdate = false;

        const anchorPose = pose ? new THREE.Matrix4().fromArray(pose.transform.matrix) : new THREE.Matrix4().copy(reticle.matrix);
        const desiredPlacement = computePlacementMatrixFromMatrix(anchorPose);
        const inverseAnchorPose = anchorPose.clone().invert();
        const offsetMatrix = inverseAnchorPose.multiply(desiredPlacement);

        anchorGroup.matrix.copy(desiredPlacement);
        PLACEMENTS_ROOT.add(anchorGroup);

        const placed = cloneModel(modelTemplate);
        placed.scale.copy(modelTemplate.scale);
        anchorGroup.add(placed);

        currentAnchor = { anchor, group: anchorGroup, fallback: false, offsetMatrix };
        currentModel = placed;
      } else {
        // fallback (no anchor)
        infoEl.textContent = "Anchors not available — fallback placement.";
        const fallbackGroup = new THREE.Group();
        fallbackGroup.matrixAutoUpdate = false;
        const desired = computePlacementMatrixFromMatrix(reticle.matrix);
        fallbackGroup.matrix.copy(desired);
        PLACEMENTS_ROOT.add(fallbackGroup);

        const placed = cloneModel(modelTemplate);
        placed.scale.copy(modelTemplate.scale);
        fallbackGroup.add(placed);

        currentAnchor = { anchor: null, group: fallbackGroup, fallback: true };
        currentModel = placed;
      }
    } catch (e) {
      console.error("placeAnchor error:", e);
    } finally {
      isPlacing = false;
    }
  }

  // controller select
  const controller = renderer.xr.getController(0);
  controller.addEventListener('select', () => {
    if (reticle.visible) placeAnchorFromLastHit();
  });
  scene.add(controller);

  // click desktop fallback
  window.addEventListener('click', () => {
    const session = renderer.xr.getSession();
    if (session && reticle.visible) placeAnchorFromLastHit();
  });

  // opacity slider
  const opacitySlider = document.getElementById("opacityControl");
  opacitySlider.addEventListener("input", (e) => {
    const value = parseFloat(e.target.value);
    if (currentModel) {
      currentModel.traverse((node) => {
        if (node.isMesh && node.material) node.material.opacity = value;
      });
    }
  });

  // Reset AR
  resetBtn.addEventListener('click', () => {
    const session = renderer.xr.getSession();
    if (session) session.end();
  });

  // session management: request hit-test on sessionstart (safer)
  renderer.xr.addEventListener('sessionstart', async () => {
    const session = renderer.xr.getSession();
    infoEl.textContent = "AR session started — move device to find surfaces.";
    try {
      // request viewer reference space and hit test source (may fail — handled)
      const viewerSpace = await session.requestReferenceSpace('viewer').catch(()=>null);
      if (viewerSpace) {
        const source = await session.requestHitTestSource({ space: viewerSpace }).catch(()=>null);
        if (source) {
          hitTestSource = source;
        } else {
          hitTestSource = null;
        }
      }
    } catch (e) {
      console.warn("hit test request failed:", e);
      hitTestSource = null;
    }

    // cleanup on end
    session.addEventListener('end', () => {
      if (hitTestSource && typeof hitTestSource.cancel === 'function') {
        try { hitTestSource.cancel(); } catch(e) {}
      }
      hitTestSource = null;
      lastHitResult = null;
      clearAllPlacementsAndAnchors();
      infoEl.textContent = "AR session ended.";
    });
  });

  // render loop
  renderer.setAnimationLoop((timestamp, frame) => {
    if (frame) {
      const referenceSpace = renderer.xr.getReferenceSpace();
      const session = renderer.xr.getSession();

      if (hitTestSource && referenceSpace) {
        const hitTestResults = frame.getHitTestResults(hitTestSource);
        if (hitTestResults.length > 0) {
          const hit = hitTestResults[0];
          lastHitResult = hit;
          const pose = hit.getPose(referenceSpace);
          if (pose) {
            reticle.visible = true;
            reticle.matrix.fromArray(pose.transform.matrix);
          } else {
            reticle.visible = false;
          }
        } else {
          lastHitResult = null;
          reticle.visible = false;
        }
      }

      // update anchor group if real anchor exists
      if (currentAnchor && currentAnchor.anchor && !currentAnchor.fallback) {
        try {
          const anchorPose = frame.getPose(currentAnchor.anchor.anchorSpace, referenceSpace);
          if (anchorPose) {
            const anchorMat = new THREE.Matrix4().fromArray(anchorPose.transform.matrix);
            const finalMat = anchorMat.clone().multiply(currentAnchor.offsetMatrix);
            currentAnchor.group.matrix.copy(finalMat);
          }
        } catch (e) { /* ignore */ }
      }
    }

    renderer.render(scene, camera);
  });

  // touch rotate
  renderer.domElement.addEventListener("touchstart", (e) => {
    if (e.touches.length === 1) {
      isDragging = true;
      previousTouchX = e.touches[0].clientX;
    }
  });
  renderer.domElement.addEventListener("touchmove", (e) => {
    if (isDragging && currentModel && e.touches.length === 1) {
      const deltaX = e.touches[0].clientX - previousTouchX;
      previousTouchX = e.touches[0].clientX;
      currentModel.rotation.y += deltaX * 0.01;
    }
  });
  renderer.domElement.addEventListener("touchend", () => { isDragging = false; });

  // resize
  window.addEventListener("resize", () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

  // final sessionend handling (in case)
  renderer.xr.addEventListener('sessionend', () => {
    clearAllPlacementsAndAnchors();
    hitTestSource = null;
    infoEl.textContent = "XR session ended.";
  });

  </script>
</body>
</html>
