<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <title>WebXR AR Anchored Model + Marker Tracking</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
    #opacityControl {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10;
    }
    #info {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 10;
      background: rgba(0,0,0,0.4);
      color: white;
      padding: 6px 8px;
      font-family: monospace;
      font-size: 13px;
      border-radius: 6px;
      white-space: pre-line;
    }
    #resetBtn {
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 10;
      background: rgba(255,255,255,0.9);
      color: #111;
      padding: 6px 10px;
      font-family: system-ui, sans-serif;
      font-size: 13px;
      border: 1px solid #ccc;
      border-radius: 6px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div id="info">Đang chờ khởi động AR...</div>
  <button id="resetBtn" type="button">Reset AR</button>
  <input type="range" id="opacityControl" min="0" max="1" step="0.05" value="1">

  <script type="module">
  import * as THREE from "https://esm.sh/three@0.160.0";
  import { GLTFLoader } from "https://esm.sh/three@0.160.0/examples/jsm/loaders/GLTFLoader.js";
  import { ARButton } from "https://esm.sh/three@0.160.0/examples/jsm/webxr/ARButton.js";

  const infoEl = document.getElementById("info");
  const resetBtn = document.getElementById("resetBtn");

  let modelTemplate = null;
  let currentAnchor = null;
  let reticle;
  let hitTestSource = null;
  let lastHitResult = null;
  let currentModel = null;
  let isDragging = false;
  let previousTouchX = 0;
  let isPlacing = false;
  const allAnchors = new Set();

  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.01, 20);
  const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.xr.enabled = true;
  document.body.appendChild(renderer.domElement);

  const PLACEMENTS_ROOT = new THREE.Group();
  scene.add(PLACEMENTS_ROOT);

  async function initARButton() {
    if (!("xr" in navigator)) { infoEl.textContent = "Trình duyệt không hỗ trợ WebXR."; return; }
    const supported = await navigator.xr.isSessionSupported("immersive-ar");
    if (!supported) { infoEl.textContent = "Thiết bị không hỗ trợ AR."; return; }
    const imgBitmap = await fetch("marker.png").then(r=>r.blob());
    document.body.appendChild(ARButton.createButton(renderer, {
      requiredFeatures: ["image-tracking"],
      trackedImages: [
        {
          image: imgBitmap,
          widthInMeters: 0.15
        }
      ],
      optionalFeatures: ["hit-test", "anchors", "dom-overlay"],
      domOverlay: { root: document.body }
    }));
  }
  initARButton();

  scene.add(new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1));

  const ringGeo = new THREE.RingGeometry(0.08,0.1,32).rotateX(-Math.PI/2);
  const ringMat = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
  reticle = new THREE.Mesh(ringGeo, ringMat);
  reticle.matrixAutoUpdate = false;
  reticle.visible = false;
  scene.add(reticle);

  const loader = new GLTFLoader();
  loader.load("test.glb", (gltf)=>{
    modelTemplate = gltf.scene;
    modelTemplate.scale.set(0.2,0.2,0.2);
    infoEl.textContent = "Model đã load — di chuyển camera để tìm mặt phẳng.";
  }, undefined, (err)=>{
    console.error("GLTF load error:", err);
    infoEl.textContent = "Lỗi load GLTF — xem console.";
  });

  function cloneModel(template) {
    const clone = template.clone(true);
    clone.traverse((n)=>{
      if (n.isMesh && n.material) {
        n.material = n.material.clone();
        n.material.transparent = true;
        n.material.userData.__cloned = true;
      }
    });
    return clone;
  }

  function clearAllPlacementsAndAnchors() {
    if (allAnchors.size) {
      for (const a of allAnchors) { try { if (a.delete) a.delete(); } catch(e){} }
      allAnchors.clear();
    }
    while (PLACEMENTS_ROOT.children.length) {
      const child = PLACEMENTS_ROOT.children[0];
      PLACEMENTS_ROOT.remove(child);
    }
    currentAnchor = null;
    currentModel = null;
  }

  // --- orientation helpers ---
  let _lastHDir = new THREE.Vector3(1, 0, 0);
  function getCameraHorizontalDir() {
    const fwd = new THREE.Vector3();
    camera.getWorldDirection(fwd);
    fwd.y = 0;
    const len = fwd.length();
    if (len < 1e-3) return _lastHDir.clone();
    fwd.divideScalar(len);
    _lastHDir.copy(fwd);
    return fwd;
  }
  function computePlacementMatrixFromMatrix(baseMatrix) {
    const poseMat = new THREE.Matrix4().copy(baseMatrix);
    const rotMat = new THREE.Matrix4().extractRotation(poseMat);
    const normal = new THREE.Vector3(0,1,0).applyMatrix4(rotMat).normalize();
    const camH = getCameraHorizontalDir();
    const camProj = camH.clone().projectOnPlane(normal);
    if (camProj.length() < 1e-3) {
      camProj.copy(_lastHDir).projectOnPlane(normal);
      if (camProj.length() < 1e-3) camProj.set(1,0,0);
    }
    camProj.normalize();
    const xAxis = camProj.clone();
    const yAxis = normal.clone().normalize();
    const zAxis = new THREE.Vector3().crossVectors(yAxis, xAxis).normalize();
    const basis = new THREE.Matrix4().makeBasis(xAxis, yAxis, zAxis);
    const pos = new THREE.Vector3().setFromMatrixPosition(poseMat);
    basis.setPosition(pos);
    return basis;
  }

  async function placeAnchorFromLastHit() {
    if (isPlacing) return;
    isPlacing = true;
    const hit = lastHitResult;
    const refSpace = renderer.xr.getReferenceSpace();
    if (!hit || !refSpace || !modelTemplate) { isPlacing=false; return; }
    clearAllPlacementsAndAnchors();
    const pose = hit.getPose(refSpace);
    const anchor = await hit.createAnchor?.(refSpace).catch(()=>null);
    const group = new THREE.Group();
    group.matrixAutoUpdate=false;
    if (pose) {
      // dùng orientation helper để đặt matrix
      const placementMatrix = computePlacementMatrixFromMatrix(new THREE.Matrix4().fromArray(pose.transform.matrix));
      group.matrix.copy(placementMatrix);
    }
    PLACEMENTS_ROOT.add(group);
    const placed = cloneModel(modelTemplate);
    group.add(placed);
    currentModel = placed;
    currentAnchor = { anchor, group };
    if (anchor) allAnchors.add(anchor);
    isPlacing=false;
  }

  const controller = renderer.xr.getController(0);
  controller.addEventListener("select", ()=>{ if (reticle.visible) placeAnchorFromLastHit(); });
  scene.add(controller);
  window.addEventListener("click", ()=>{ const s=renderer.xr.getSession(); if (s && reticle.visible) placeAnchorFromLastHit(); });

  document.getElementById("opacityControl").addEventListener("input",(e)=>{
    const v = parseFloat(e.target.value);
    if (currentModel) {
      currentModel.traverse((n)=>{ if (n.isMesh && n.material) n.material.opacity=v; });
    }
  });

  resetBtn.addEventListener("click",()=>{ const s=renderer.xr.getSession(); if (s) s.end(); });

  renderer.xr.addEventListener("sessionstart", async ()=>{
    const session = renderer.xr.getSession();
    infoEl.textContent = "Đã vào chế độ AR, di chuyển để quét mặt phẳng hoặc marker...";
    const viewerSpace = await session.requestReferenceSpace("viewer");
    hitTestSource = await session.requestHitTestSource({ space: viewerSpace }).catch(()=>null);
    if (session.updateTargetImages) {
      try {
        const img = await fetch("marker.png").then(r=>r.blob());
        await session.updateTargetImages([{ image: img, widthInMeters: 0.15 }]);
        alert("Đã đăng ký marker tracking");
      } catch(e) { alert("Không thể đăng ký marker:", e); }
    }
    session.addEventListener("end", ()=>{ hitTestSource = null; clearAllPlacementsAndAnchors(); infoEl.textContent = "AR session đã kết thúc."; });
  });

  renderer.setAnimationLoop((t,frame)=>{
    if (frame) {
      const refSpace = renderer.xr.getReferenceSpace();
      if (hitTestSource && refSpace) {
        const hits = frame.getHitTestResults(hitTestSource);
        if (hits.length>0) {
          lastHitResult = hits[0];
          const pose = hits[0].getPose(refSpace);
          if (pose) { reticle.visible=true; reticle.matrix.fromArray(pose.transform.matrix); }
        } else { reticle.visible=false; }
      }
      const results = frame.getImageTrackingResults?.() || [];
      for (const result of results) {
        const state = result.trackingState;
        if (state==="tracked") {
          const pose = frame.getPose(result.imageSpace, refSpace);
          if (pose) {
            const p = pose.transform.position;
            const q = pose.transform.orientation;
            infoEl.textContent = 
              `Marker tracked!\n`+
              `Vị trí: x=${p.x.toFixed(2)}, y=${p.y.toFixed(2)}, z=${p.z.toFixed(2)}\n`+
              `Hướng (quat): x=${q.x.toFixed(2)}, y=${q.y.toFixed(2)}, z=${q.z.toFixed(2)}, w=${q.w.toFixed(2)}`;
          }
        }
      }
    }
    renderer.render(scene,camera);
  });

  renderer.domElement.addEventListener("touchstart",(e)=>{ if (e.touches.length===1) { isDragging=true; previousTouchX=e.touches[0].clientX; } });
  renderer.domElement.addEventListener("touchmove",(e)=>{ if (isDragging && currentModel && e.touches.length===1) { const dx=e.touches[0].clientX-previousTouchX; previousTouchX=e.touches[0].clientX; currentModel.rotation.y += dx*0.01; } });
  renderer.domElement.addEventListener("touchend",()=>{ isDragging=false; });

  window.addEventListener("resize",()=>{ camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
  </script>
</body>
</html>
