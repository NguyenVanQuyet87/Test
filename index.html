<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <title>WebXR AR với Marker Tracking và Hiệu Ứng Quét</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
    #opacityControl {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10;
    }
    #info {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 10;
      background: rgba(0,0,0,0.4);
      color: white;
      padding: 6px 8px;
      font-family: monospace;
      font-size: 13px;
      border-radius: 6px;
      white-space: pre-line;
      max-width: 80%;
    }
    #resetBtn {
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 10;
      background: rgba(255,255,255,0.9);
      color: #111;
      padding: 6px 10px;
      font-family: system-ui, sans-serif;
      font-size: 13px;
      border: 1px solid #ccc;
      border-radius: 6px;
      cursor: pointer;
    }
    #markerStatus {
      position: absolute;
      bottom: 60px;
      left: 10px;
      z-index: 10;
      background: rgba(0,0,0,0.4);
      color: white;
      padding: 6px 8px;
      font-family: monospace;
      font-size: 13px;
      border-radius: 6px;
    }
    #selectBtn {
      position: absolute;
      bottom: 200px;
      right: 10px;
      z-index: 10;
      background: rgba(255,255,255,0.9);
      color: #111;
      padding: 8px 12px;
      font-family: system-ui, sans-serif;
      font-size: 13px;
      border: 1px solid #ccc;
      border-radius: 6px;
      cursor: pointer;
      
    }
    #placementBtn {
      position: absolute;
      bottom: 300px;
      right: 10px;
      z-index: 10;
      background: rgba(255,255,255,0.9);
      color: #111;
      padding: 8px 12px;
      font-family: system-ui, sans-serif;
      font-size: 13px;
      border: 1px solid #ccc;
      border-radius: 6px;
      cursor: pointer;
      
    }
    #adjustBtn {
      position: absolute;
      bottom: 250px;
      right: 10px;
      z-index: 10;
      background: rgba(255,255,255,0.9);
      color: #111;
      padding: 8px 12px;
      font-family: system-ui, sans-serif;
      font-size: 13px;
      border: 1px solid #ccc;
      border-radius: 6px;
      cursor: pointer;
    }
    #heightSlider {
      display: none;
      position: absolute;
      left: 10px;
      top: 50%;
      transform: translateY(-50%);
      writing-mode: vertical-lr;
      width: 8px;
      height: 200px;
      z-index: 10;
    }
    #rotationSlider {
      display: none;
      position: absolute;
      bottom: 60px;
      left: 50%;
      transform: translateX(-50%);
      width: 80%;
      z-index: 10;
    }
    #hud {
      position: absolute;
      top: 50px;
      left: 50%;
      transform: translateX(-50%);
      padding: 10px 15px;
      background: rgba(0,0,0,0.1);
      color: #ffffff;
      font-family: monospace;
      font-size: 14px;
      border-radius: 8px;
      text-align: left;
      line-height: 1.4;
      pointer-events: none; /* không ảnh hưởng tới thao tác */
    }
    /* Hiệu ứng quét QR code */
    #markerOverlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 5;
      display: none;
    }
    .qr-frame {
      position: absolute;
      border: 4px solid transparent;
      border-radius: 12px;
      box-shadow: 0 0 20px rgba(255, 255, 0, 0.7);
      animation: pulse 1.5s infinite alternate;
    }
    .qr-corner {
      position: absolute;
      width: 20px;
      height: 20px;
      border: 4px solid #ff0;
    }
    .qr-corner-tl {
      top: -4px;
      left: -4px;
      border-right: none;
      border-bottom: none;
      border-top-left-radius: 8px;
    }
    .qr-corner-tr {
      top: -4px;
      right: -4px;
      border-left: none;
      border-bottom: none;
      border-top-right-radius: 8px;
    }
    .qr-corner-bl {
      bottom: -4px;
      left: -4px;
      border-right: none;
      border-top: none;
      border-bottom-left-radius: 8px;
    }
    .qr-corner-br {
      bottom: -4px;
      right: -4px;
      border-left: none;
      border-top: none;
      border-bottom-right-radius: 8px;
    }
    .scan-line {
      position: absolute;
      height: 3px;
      width: 100%;
      background: linear-gradient(to right, transparent, #ff0, transparent);
      top: 50%;
      animation: scan 2s linear infinite;
    }
    @keyframes pulse {
      0% { box-shadow: 0 0 10px rgba(255, 255, 0, 0.5); }
      100% { box-shadow: 0 0 30px rgba(255, 255, 0, 1); }
    }
    @keyframes scan {
      0% { top: 0%; opacity: 0; }
      10% { opacity: 1; }
      90% { opacity: 1; }
      100% { top: 100%; opacity: 0; }
    }
  </style>
</head>
<body>
  <div id="info">Đang chờ khởi động AR...</div>
  <div id="markerStatus">Chưa phát hiện marker</div>
  //<button id="resetBtn" type="button">Reset AR</button>
  <button id="placementBtn" type="button">Placement</button>
  <button id="adjustBtn" type="button">Adjust</button>
  <button id="selectBtn" type="button">Select</button>
  <input type="range" id="opacityControl" min="0" max="1" step="0.05" value="1">
  <div id="hud"></div>
  
  <!-- Overlay hiệu ứng quét QR code -->
  <div id="markerOverlay">
    <div class="qr-frame">
      <div class="qr-corner qr-corner-tl"></div>
      <div class="qr-corner qr-corner-tr"></div>
      <div class="qr-corner qr-corner-bl"></div>
      <div class="qr-corner qr-corner-br"></div>
      <div class="scan-line"></div>
    </div>
  </div>

  <!-- Thanh kéo độ cao (Z) -->
  <input type="range" id="heightSlider" min="-1" max="1" step="0.01" value="0">

  <!-- Thanh kéo quay (rotation quanh Z) -->
  <input type="range" id="rotationSlider" min="-180" max="180" step="1" value="0">

  <script type="module">
  import * as THREE from "https://esm.sh/three@0.160.0";
  import { GLTFLoader } from "https://esm.sh/three@0.160.0/examples/jsm/loaders/GLTFLoader.js";
  import { ARButton } from "https://esm.sh/three@0.160.0/examples/jsm/webxr/ARButton.js";

  const infoEl = document.getElementById("info");
  const markerStatusEl = document.getElementById("markerStatus");
  const resetBtn = document.getElementById("resetBtn");
  const placementBtn = document.getElementById("placementBtn");
    const selectBtn = document.getElementById("selectBtn");
  const adjustBtn = document.getElementById("adjustBtn");
  const markerOverlay = document.getElementById("markerOverlay");
  const qrFrame = document.querySelector('.qr-frame');
  const heightSlider = document.getElementById("heightSlider");
  const rotationSlider = document.getElementById("rotationSlider");

  let modelTemplate = null;
  let currentAnchor = null;
  let reticle;
  let hitTestSource = null;
  let lastHitResult = null;
  let currentModel = null;
  let isDragging = false;
  let previousTouchX = 0;
  let previousTouchY = 0;
  let isPlacing = false;
  let markerDetected = false;
  let markerPose = null;
  const allAnchors = new Set();
  let adjustMode = false;
  let axesGroup = null;
  let lastHeightValue = 0;
  let lastRotationValue = 0;

  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.01, 20);
  const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, precision: "highp" });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.xr.enabled = true;
  document.body.appendChild(renderer.domElement);
    
  const PLACEMENTS_ROOT = new THREE.Group();
  scene.add(PLACEMENTS_ROOT);

  // Hàm cập nhật vị trí và kích thước của hiệu ứng quét QR dựa trên vị trí marker
  function updateQRFramePosition(pose) {
    if (!pose) return;
    
    // Lấy ma trận chuyển đổi từ pose
    const matrix = new THREE.Matrix4().fromArray(pose.transform.matrix);
    const position = new THREE.Vector3();
    const scale = new THREE.Vector3();
    const quaternion = new THREE.Quaternion();
    matrix.decompose(position, quaternion, scale);
    
    // Chuyển đổi vị trí 3D sang tọa độ màn hình 2D
    const vector = position.clone();
    vector.project(camera);
    
    const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
    const y = -(vector.y * 0.5 - 0.5) * window.innerHeight;
    
    // Ước tính kích thước của marker trên màn hình dựa trên khoảng cách
    const distance = position.distanceTo(camera.position);
    const markerSize = (0.15 / distance) * 500; // 0.15 là widthInMeters của marker
    
    // Cập nhật vị trí và kích thước của khung QR
    qrFrame.style.width = `${markerSize}px`;
    qrFrame.style.height = `${markerSize}px`;
    qrFrame.style.left = `${x - markerSize/2}px`;
    qrFrame.style.top = `${y - markerSize/2}px`;
    
    // Hiển thị overlay
    markerOverlay.style.display = 'block';
  }

  // Ẩn hiệu ứng quét QR
  function hideQRFrame() {
    markerOverlay.style.display = 'none';
  }

  async function initARButton() {
    if (!("xr" in navigator)) { infoEl.textContent = "Trình duyệt không hỗ trợ WebXR."; return; }
    const supported = await navigator.xr.isSessionSupported("immersive-ar");
    if (!supported) { infoEl.textContent = "Thiết bị không hỗ trợ AR."; return; }
    // Load marker image
    try {
      const imgBitmap = await fetch("marker.png")
        .then(r => r.blob())
        .then(b => createImageBitmap(b));
      
      document.body.appendChild(ARButton.createButton(renderer, {
        requiredFeatures: ["image-tracking"],
        trackedImages: [
          {
            image: imgBitmap,
            widthInMeters: 0.15
          }
        ],
        optionalFeatures: ["hit-test", "anchors", "dom-overlay"],
        domOverlay: { root: document.body }
      }));
    } catch (e) {
      console.error("Lỗi khi tải marker:", e);
      infoEl.textContent = "Lỗi khi tải marker.png - vui lòng kiểm tra file và console";
    }
  }
  initARButton();

  // Tạo ánh sáng cho vật liệu
  scene.add(new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1));
  scene.add(new THREE.AmbientLight(0xffffff, 0.6));
  const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
  dirLight.position.set(5, 10, 7);
  scene.add(dirLight);
    
  const ringGeo = new THREE.RingGeometry(0.08,0.1,32).rotateX(-Math.PI/2);
  const ringMat = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
  reticle = new THREE.Mesh(ringGeo, ringMat);
  reticle.matrixAutoUpdate = false;
  reticle.visible = false;
  scene.add(reticle);

  // Tạo hình khối mẫu nếu không tải được GLTF
  function createFallbackModel() {
    const geometry = new THREE.BoxGeometry(1, 1, 1);
    const material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
    const cube = new THREE.Mesh(geometry, material);
    const group = new THREE.Group();
    group.add(cube);
    group.scale.set(1, 1, 1);
    return group;
  }
  // Hệ tọa độ của file GTLF thì trục Y sẽ hướng lên trên, trục Z hướng dọc mô hình
  const loader = new GLTFLoader();
  loader.load("test.glb", (gltf)=>{
    modelTemplate = gltf.scene;
    modelTemplate.scale.set(0.2,0.2,0.2);
    // Xoay từ hệ glTF (+Y up) sang hệ WebXR
    modelTemplate.rotation.x = Math.PI / 2;
    console.log(gltf.scene)
    console.log(gltf.parser)
    infoEl.textContent = "Model đã load — di chuyển camera để tìm mặt phẳng hoặc marker.";
    
  }, undefined, (err)=>{
    console.error("GLTF load error:", err);
    infoEl.textContent = "Lỗi load GLTF — tạo model mẫu thay thế.";
    modelTemplate = createFallbackModel();
  });
    
// Hàm chỉnh vật liệu
function adjustMaterial(material) {
  if (material instanceof THREE.MeshPhongMaterial) {
    material.shininess = 50; // bóng loáng hơn
  }
  if (material instanceof THREE.MeshStandardMaterial || 
      material instanceof THREE.MeshPhysicalMaterial) {
    material.roughness = 0.2; // càng nhỏ càng bóng
    material.metalness = 0.5; // càng cao càng giống gương
  }
  material.needsUpdate = true;
}
    
  function cloneModel(template) {
    const clone = template.clone(true);
    clone.traverse((n)=>{
      if (n.isMesh && n.material) {
        n.material = n.material.clone();
        n.material.transparent = true;
        n.material.userData.__cloned = true;
        if (Array.isArray(n.material)) {
          n.material.forEach(m => adjustMaterial(m));
        } else {
          adjustMaterial(n.material);
        }
      }
    });
    return clone;
  }

  function clearAllPlacementsAndAnchors() {
    if (allAnchors.size) {
      for (const a of allAnchors) { try { if (a.delete) a.delete(); } catch(e){} }
      allAnchors.clear();
    }
    while (PLACEMENTS_ROOT.children.length) {
      const child = PLACEMENTS_ROOT.children[0];
      PLACEMENTS_ROOT.remove(child);
    }
    currentAnchor = null;
    currentModel = null;
  }

    // Hàm đặt mô hình lên marker với hướng trục X trùng với pháp tuyến của marker
function placeModelOnMarker(pose) {
    if (!modelTemplate || isPlacing) return;
    
    isPlacing = true;
    clearAllPlacementsAndAnchors();
    
    const group = new THREE.Group();
    group.matrixAutoUpdate = false;
    
    // Sử dụng ma trận từ pose của marker
    // matrix/quaternion đã lấy từ pose
    const matrix = new THREE.Matrix4().fromArray(pose.transform.matrix);
    const position = new THREE.Vector3();
    const quaternion = new THREE.Quaternion();
    const scale = new THREE.Vector3();
    matrix.decompose(position, quaternion, scale);
    
    // Các trục trong hệ local của marker (KHÔNG PHẢI trục world)
    const localX = new THREE.Vector3(1,0,0); // nằm trên mặt
    const localY = new THREE.Vector3(0,1,0); // PHÁP TUYẾN marker
    const localZ = new THREE.Vector3(0,0,1); // nằm trên mặt
    // Đưa sang world
    const markerRight  = localX.clone().applyQuaternion(quaternion); // nằm ngang
    const markerNormal = localY.clone().applyQuaternion(quaternion); // pháp tuyến mặt
    const markerUp = localZ.clone().applyQuaternion(quaternion); // nằm ngang
    
    let modelXAxis = markerNormal.clone().negate();   // +X model = vào trong marker (ngược với normal)
    let modelYAxis = markerRight.clone().negate();                // +Z model = lên trên
    let modelZAxis = markerUp.clone().negate();                // +Z model = lên trên
    
    // Bảo đảm trực giao/chuẩn hoá
    modelXAxis.normalize();
    modelZAxis.normalize();
    modelYAxis.copy(new THREE.Vector3().crossVectors(modelZAxis, modelXAxis)).normalize();
    
    // Tạo ma trận biến đổi
    const modelMatrix = new THREE.Matrix4().makeBasis(modelXAxis, modelYAxis, modelZAxis);
    modelMatrix.setPosition(position);
    
    // Áp dụng ma trận cho group
    group.matrix.copy(modelMatrix);
    
    PLACEMENTS_ROOT.add(group);
    
    const placed = cloneModel(modelTemplate);
    group.add(placed);
    currentModel = placed;
    
    // Tạo anchor nếu có thể
    if (pose && pose.createAnchor) {
      pose.createAnchor().then(anchor => {
        currentAnchor = { anchor, group };
        allAnchors.add(anchor);
      }).catch(console.error);
    }
    
    infoEl.textContent = "Model đã được đặt trên marker! Trục X vào marker, Y sang trái, Z lên trên.";
    
    markerDetected = false;
    
    // Ẩn hiệu ứng quét sau khi đặt model
    hideQRFrame();
    
    // Debug: hiển thị các trục của marker
    debugAxes(group, modelXAxis, modelYAxis, modelZAxis);
}

// Hàm debug để hiển thị các trục
function debugAxes(group, xAxis, yAxis, zAxis) {
    const axisLength = 0.2;
    
    // Trục X (đỏ) - hướng vào marker
    const xGeometry = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(0, 0, 0),
        new THREE.Vector3(axisLength, 0, 0,)
    ]);
    const xMaterial = new THREE.LineBasicMaterial({ color: 0xff0000 });
    const xAxisLine = new THREE.Line(xGeometry, xMaterial);
    group.add(xAxisLine);
    
    // Trục Y (xahn lá) - hướng sang trái
    const yGeometry = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(0, 0, 0),
        new THREE.Vector3(0, axisLength, 0)
    ]);
    const yMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00 });
    const yAxisLine = new THREE.Line(yGeometry, yMaterial);
    group.add(yAxisLine);
    
    // Trục Z (xanh dương) - hướng lên trên
    const zGeometry = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(0, 0, 0),
        new THREE.Vector3(0, 0, axisLength)
    ]);
    const zMaterial = new THREE.LineBasicMaterial({ color: 0x0000ff });
    const zAxisLine = new THREE.Line(zGeometry, zMaterial);
    group.add(zAxisLine);
}
    
  // --- orientation helpers ---
  let _lastHDir = new THREE.Vector3(1, 0, 0);
  function getCameraHorizontalDir() {
    const fwd = new THREE.Vector3();
    camera.getWorldDirection(fwd);
    fwd.y = 0;
    const len = fwd.length();
    if (len < 1e-3) return _lastHDir.clone();
    fwd.divideScalar(len);
    _lastHDir.copy(fwd);
    return fwd;
  }

function computePlacementMatrixFromMatrix(baseMatrix) {
  const poseMat = new THREE.Matrix4().copy(baseMatrix);

  // Lấy normal từ mặt phẳng (giữ là "up")
  const rotMat = new THREE.Matrix4().extractRotation(poseMat);
  const normal = new THREE.Vector3(0,1,0).applyMatrix4(rotMat).normalize();

  // Lấy hướng forward theo camera (x-axis theo định nghĩa của bạn)
  const camFwd = getCameraHorizontalDir();

  // Chiếu forward lên mặt phẳng
  const camProj = camFwd.clone().projectOnPlane(normal);
  if (camProj.length() < 1e-3) {
    camProj.copy(_lastHDir).projectOnPlane(normal);
    if (camProj.length() < 1e-3) camProj.set(1,0,0);
  }
  camProj.normalize();

  // Đặt trục theo quy ước mới
  const xAxis = camProj.clone();                   // X = ra khỏe camera
  const zAxis = normal.clone().normalize();        // Z = lên trên
  const yAxis = new THREE.Vector3().crossVectors(zAxis, xAxis).normalize(); 
  // Y = trái (cross theo Z × X)

  // Tạo hệ cơ sở
  const basis = new THREE.Matrix4().makeBasis(xAxis, yAxis, zAxis);

  // Đặt vị trí
  const pos = new THREE.Vector3().setFromMatrixPosition(poseMat);
  basis.setPosition(pos);

  return basis;
}

  async function placeAnchorFromLastHit() {
    if (isPlacing) return;
    const hit = lastHitResult;
    const refSpace = renderer.xr.getReferenceSpace();
    if (!hit || !refSpace || !modelTemplate) { isPlacing=false; return; }
    clearAllPlacementsAndAnchors();
    const pose = hit.getPose(refSpace);
    const anchor = await hit.createAnchor?.(refSpace).catch(()=>null);

 // Nếu không tạo được anchor thì bỏ qua
  if (!pose || !anchor) {
   infoEl.textContent = "Không thể tạo anchor, mô hình sẽ không được đặt.";
    isPlacing = false;
    return;
  }

    const group = new THREE.Group();
    group.matrixAutoUpdate=false;
    if (pose) {
      const placementMatrix = computePlacementMatrixFromMatrix(new THREE.Matrix4().fromArray(pose.transform.matrix));
      group.matrix.copy(placementMatrix);
    }
    PLACEMENTS_ROOT.add(group);
    const placed = cloneModel(modelTemplate);
    group.add(placed);
    currentModel = placed;
    currentAnchor = { anchor, group };
    if (anchor) allAnchors.add(anchor);
    infoEl.textContent = "Mô hình đã được đặt và neo thành công!";
  }

  const controller = renderer.xr.getController(0);
  controller.addEventListener("select", ()=>{ if (reticle.visible) placeAnchorFromLastHit(); });
  scene.add(controller);
 renderer.domElement.addEventListener("click", ()=>{ 
    const s=renderer.xr.getSession(); 
    if (s && reticle.visible && !isPlacing) {
      placeAnchorFromLastHit(); 
      isPlacing = true;
    }
    if (isPlacing) {
      // Raycast từ tâm màn hình
      const hit = getIntersects();
      if (hit) {
        const obj = hit.object;
        if (obj.material) {
          obj.material.color.set(0xff7e21);
        }
        infoEl.textContent = `Chọn: ${obj.name}`;
      }
    }
  });

  placementBtn.addEventListener("click", (e)=>{
    e.stopPropagation();
    isPlacing = !isPlacing;
    if (!isPlacing) {
      infoEl.textContent = "Bạn đang ở chế độ đặt mô hình.";
    } else {
      infoEl.textContent = "Bạn vừa thoát khỏi chế độ đặt mô hình.";
    }
  });
  selectBtn.addEventListener("click", ()=>{
      // Raycast từ tâm màn hình
      const hit = getIntersects();
      if (hit) {
        const obj = hit.object;
        if (obj.material) {
          obj.material.color.set(0xff7e21);
        }
        infoEl.textContent = `Chọn: ${obj.name}`;
      }
  });
  document.getElementById("opacityControl").addEventListener("input",(e)=>{
    const v = parseFloat(e.target.value);
    if (currentModel) {
      currentModel.traverse((n)=>{ if (n.isMesh && n.material) n.material.opacity=v; });
    }
  });

  //resetBtn.addEventListener("click",()=>{ 
    //const s=renderer.xr.getSession(); 
    //if (s) s.end(); 
    //hideQRFrame();
  //});

  adjustBtn.addEventListener("click", () => {
    adjustMode = !adjustMode;
    heightSlider.style.display = adjustMode ? 'block' : 'none';
    rotationSlider.style.display = adjustMode ? 'block' : 'none';
    if (adjustMode) {
      heightSlider.value = 0;
      rotationSlider.value = 0;
      lastHeightValue = 0;
      lastRotationValue = 0;
      const hit = getIntersects();
      createAxesAtHit(hit);
    } else {
      // Xóa hệ trục khi tắt chế độ Adjust
      if (axesGroup) {
        const group = currentAnchor.group;
        group.remove(axesGroup);
        axesGroup = null;
      }
    }
  });

  heightSlider.addEventListener("input", (e) => {
    const value = parseFloat(e.target.value);
    const delta = (value - lastHeightValue) * 0.5; // Factor điều chỉnh độ nhạy
    translateAlongLocalAxis(new THREE.Vector3(0, 0, 1), delta);
    lastHeightValue = value;
  });

  rotationSlider.addEventListener("input", (e) => {
    const value = parseFloat(e.target.value);
    const deltaDeg = value - lastRotationValue;
    rotateAroundLocalAxis(new THREE.Vector3(0, 0, 1), THREE.MathUtils.degToRad(deltaDeg));
    lastRotationValue = value;
  });

  // Hàm tạo hệ trục tại vị trí hit
  function createAxesAtHit(hit) {
    const group = currentAnchor.group;
    // Xóa trục cũ nếu có
    if (axesGroup) {
      group.remove(axesGroup);
      axesGroup = null;
    }

   if (!hit && currentAnchor && currentAnchor.group) {
      const matrix = group.matrix.clone();
      const quaternion = new THREE.Quaternion();
      const position = new THREE.Vector3();
      const scale = new THREE.Vector3();
      matrix.decompose(position, quaternion, scale);
      hit = {
        point: position,
        object: group,
      };
    }

    if (!hit) return;

    // Tạo group mới cho trục
    axesGroup = new THREE.Group();
    
    // Chiều dài trục (kéo dài 3m mỗi phía)
    const axisLen = 1;
    function createAxis(length, color) {
      const axisGroup = new THREE.Group();
    
      // Thân trụ
      const cylGeom = new THREE.CylinderGeometry(0.001, 0.001, length, 16);
      const cylMat = new THREE.MeshBasicMaterial({ color });
      const cyl = new THREE.Mesh(cylGeom, cylMat);
      cyl.position.y = length / 2; // dịch lên một nửa chiều dài
      axisGroup.add(cyl);
    
      // Mũi tên (hình nón)
      const coneGeom = new THREE.ConeGeometry(0.005, 0.02, 16);
      const coneMat = new THREE.MeshBasicMaterial({ color });
      const cone = new THREE.Mesh(coneGeom, coneMat);
      cone.position.y = 0.2; // trên đỉnh thân trụ
      axisGroup.add(cone);
    
      return axisGroup;
    }
    const axisX = createAxis(axisLen, 0xff0000);
    axisX.rotation.y = Math.PI/2; // quay thân X sang ngang
    axesGroup.add(axisX);
    
    const axisY = createAxis(axisLen, 0x00ff00);
    // mặc định dựng đứng theo Y
    axisY.rotation.z = Math.PI;
    axesGroup.add(axisY);
    
    const axisZ = createAxis(axisLen, 0x0000ff);
    axisZ.rotation.z = Math.PI/2; // quay ra theo Z
    axesGroup.add(axisZ);
    
    // Căn orientation theo object được hit
    if (hit.object) {
      // Lấy hướng của object
      const objectQuaternion = new THREE.Quaternion();
      hit.object.getWorldQuaternion(objectQuaternion);
      //group.getWorldQuaternion(objectQuaternion);
      // Áp dụng hướng cho hệ trục
      axesGroup.position.copy(hit.point);
      axesGroup.quaternion.copy(objectQuaternion);
    } else {
      // Nếu không có object, sử dụng hướng của camera
      const cameraDirection = new THREE.Vector3();
      camera.getWorldDirection(cameraDirection);
      cameraDirection.y = 0;
      cameraDirection.normalize();
      const cameraPos = new THREE.Vector3();
      camera.getWorldPosition(cameraPos);
     
      // Tạo ma trận định hướng cho trục
      const zAxis = new THREE.Vector3(0, 0, 1); // Trục Z thẳng đứng
      const xAxis = new THREE.Vector3().crossVectors(zAxis, cameraDirection).normalize(); // Trục X vuông góc với hướng camera và trục Z
      const yAxis = new THREE.Vector3().crossVectors(zAxis, xAxis).normalize(); // Trục Y vuông góc với trục X và Z
      
      // Tạo quaternion từ các trục
      const matrix = new THREE.Matrix4().makeBasis(xAxis, yAxis, zAxis);
       axesGroup.position.copy(cameraPos);
      axesGroup.quaternion.setFromRotationMatrix(matrix);
    }
    group.add(axesGroup);
    infoEl.textContent = "Đã vào chế độ Adjust. Hệ trục được tạo tại vị trí hit.";
  }
  // Tạo vòng tròn focus ở giữa màn hình (chỉ để người dùng thấy)
  const focusRing = document.createElement("div");
   const focusPoint = document.createElement("div"); 
  focusRing.style.position = "absolute";
  focusRing.style.top = "50%";
  focusRing.style.left = "50%";
  focusRing.style.width = "30px";
  focusRing.style.height = "30px";
  focusRing.style.border = "1px solid white";
  focusRing.style.borderRadius = "50%";
  focusRing.style.transform = "translate(-50%, -50%)";
  focusRing.style.pointerEvents = "none"; // không chặn click
    
  focusPoint.style.position = "absolute";
  focusPoint.style.top = "50%";
  focusPoint.style.left = "50%";
  focusPoint.style.width = "1px";
  focusPoint.style.height = "1px";
  focusPoint.style.border = "1px solid white";
  focusPoint.style.borderRadius = "50%";
  focusPoint.style.transform = "translate(-50%, -50%)";
  focusPoint.style.pointerEvents = "none"; // không chặn click   
    
  document.body.appendChild(focusRing);
    document.body.appendChild(focusPoint);
  // Raycaster và vector chuẩn hóa tâm màn hình
  const raycaster = new THREE.Raycaster();
  const center = new THREE.Vector2(0, 0); 
  function getIntersects() {
    const offsets = [
      new THREE.Vector2(0, 0),              // tia trung tâm
      //new THREE.Vector2(0.01, 0),           // lệch phải
      //new THREE.Vector2(-0.01, 0),          // lệch trái
      //new THREE.Vector2(0, 0.01),           // lệch lên
      //new THREE.Vector2(0, -0.01)           // lệch xuống
    ];
    let allHits = [];
    offsets.forEach(off => {
      const ndc = new THREE.Vector2(center.x + off.x, center.y + off.y);
      raycaster.setFromCamera(ndc, camera);
      const hits = raycaster.intersectObjects(scene.children, true);
      if (hits.length > 0) allHits.push(hits[0]); // lấy object gần nhất cho mỗi tia
    });
  
    // chọn object gần nhất trong tất cả các tia
    if (allHits.length > 0) {
      allHits.sort((a, b) => a.distance - b.distance);
      return allHits[0];
    } else {
      return null;
    }
    return null;
  }
    
  // Sự kiện bắt đầu vào chế độ AR  
  renderer.xr.addEventListener("sessionstart", async ()=>{
    const session = renderer.xr.getSession();
    infoEl.textContent = "Đã vào chế độ AR, di chuyển để quét mặt phẳng hoặc marker...";
    const viewerSpace = await session.requestReferenceSpace("viewer");
    hitTestSource = await session.requestHitTestSource({ space: viewerSpace }).catch(()=>null);
    session.addEventListener("end", ()=>{ 
      hitTestSource = null; 
      viewerSpace = null;
      clearAllPlacementsAndAnchors(); 
      infoEl.textContent = "AR session đã kết thúc.";
      markerStatusEl.textContent = "Chưa phát hiện marker";
      markerDetected = false;
      hideQRFrame();
      
      adjustMode = false;
      heightSlider.style.display = 'none';
      rotationSlider.style.display = 'none';
    });
  });

  renderer.setAnimationLoop((t,frame)=>{
    if (frame) {
      const refSpace = renderer.xr.getReferenceSpace();
      let targetPoint = null;
      if (hitTestSource && refSpace) {
        const hits = frame.getHitTestResults(hitTestSource);
        if (hits.length>0 && !adjustMode) {
          lastHitResult = hits[0];
          const pose = hits[0].getPose(refSpace);
          if (pose) { 
            reticle.visible=true; 
            reticle.matrix.fromArray(pose.transform.matrix); 
            // lấy tọa độ điểm targetPoint
            const pos = pose.transform.position;
            targetPoint = new THREE.Vector3(pos.x, pos.y, pos.z);
          } 
        } else {
            reticle.visible=false; 
          }

      }
      // 2. Nếu không có → dùng raycaster vào mô hình 3D
        const raycaster = new THREE.Raycaster();
        const screenCenter = new THREE.Vector2(0, 0); // tâm màn hình
        raycaster.setFromCamera(screenCenter, camera);
        const intersects = raycaster.intersectObjects(scene.children, true);
        if (intersects.length > 0) {
          targetPoint = intersects[0].point.clone();
        }
      
      
      // Hàm xác định khoảng cách, độ cao, độ sâu
      function getDistance(targetPoint, camera, currentAnchor) {
        if (!targetPoint) return null;
          const distance = camera.position.distanceTo(targetPoint);
          // Xác định gốc chuẩn
          let referencePos = new THREE.Vector3();
          if (currentAnchor && currentAnchor.group) {
            currentAnchor.group.getWorldPosition(referencePos);
          } else {
            referencePos.copy(camera.position);
          }
          // Tính offset theo trục Y
          const altitudeDepth = targetPoint.y - referencePos.y;
          return { distance, altitudeDepth };
      }
      const result = getDistance(targetPoint, camera, currentAnchor);
      let distance = null; 
      let altitudeDepth = null; 
      if (result) {
        distance =  result.distance;
        altitudeDepth =  result.altitudeDepth;
      }
      // Hàm hiển thị HUD
      function updateHUD(distance, altitudeDepth) {
        const hud = document.getElementById("hud");
        let label = altitudeDepth >= 0 ? "Altitude" : "Depth";
        hud.innerHTML = `Distance: ${distance !== null ? distance.toFixed(2) + " m" : "-"}<br>
          ${label}: ${altitudeDepth !== null ? Math.abs(altitudeDepth).toFixed(2) + " m" : "-"}`;
      }
      updateHUD(distance, altitudeDepth);
      // Xử lý image tracking
      const results = frame.getImageTrackingResults ? frame.getImageTrackingResults() : [];
      if (results.length > 0) {
        for (const result of results) {
          const state = result.trackingState;
          if (state === "tracked") {
            const pose = frame.getPose(result.imageSpace, refSpace);
            if (pose) {
              const p = pose.transform.position;
              markerStatusEl.textContent = 
                `Marker được nhận diện!\n`+
                `Vị trí: x=${p.x.toFixed(2)}, y=${p.y.toFixed(2)}, z=${p.z.toFixed(2)}`;
              
              // Cập nhật hiệu ứng quét QR tại vị trí marker
              updateQRFramePosition(pose);
              
              // Lưu trữ pose của marker để sử dụng sau
              markerPose = pose;
              
              // Tự động đặt model khi phát hiện marker
              if (!currentModel && modelTemplate && !markerDetected) {
                markerDetected = true;  
                // Tự động đặt mô hình sau 2 giây
                setTimeout(() => {
                  if (markerDetected && markerPose) {
                    placeModelOnMarker(markerPose);
                  }
                }, 2000);
              }
            }
          } else {
            markerStatusEl.textContent = `Marker trạng thái: ${state}`;
            markerDetected = false;
            hideQRFrame();
          }
        }
      } else {
        markerStatusEl.textContent = "Chưa phát hiện marker";
        markerDetected = false;
        hideQRFrame();
      }

    }
    renderer.render(scene,camera);

  });

  // Hàm dịch chuyển mô hình theo trục local
  function translateAlongLocalAxis(localAxis, distance) {
    if (!currentAnchor || !currentAnchor.group) return;
    const group = currentAnchor.group;
    const matrix = group.matrix.clone();
    const quaternion = new THREE.Quaternion();
    const position = new THREE.Vector3();
    const scale = new THREE.Vector3();
    matrix.decompose(position, quaternion, scale);
    const worldAxis = localAxis.clone().applyQuaternion(quaternion).normalize();
    position.add(worldAxis.multiplyScalar(distance));
    matrix.compose(position, quaternion, scale);
    group.matrix.copy(matrix);
  }
    
  // Hàm quay mô hình quanh trục local
  function rotateAroundLocalAxis(localAxis, angleRad) {
    if (!currentAnchor || !currentAnchor.group) return;
    const group = currentAnchor.group;
    const matrix = group.matrix.clone();
    const quaternion = new THREE.Quaternion();
    const position = new THREE.Vector3();
    const scale = new THREE.Vector3();
    matrix.decompose(position, quaternion, scale);
    const rotationQuat = new THREE.Quaternion().setFromAxisAngle(localAxis, angleRad);
    quaternion.multiply(rotationQuat); // Local rotation
    matrix.compose(position, quaternion, scale);
    group.matrix.copy(matrix);
  }
    
  renderer.domElement.addEventListener("touchstart",(e)=>{ 
    if (e.touches.length===1) { 
      isDragging=true; 
      previousTouchX=e.touches[0].clientX; 
      previousTouchY=e.touches[0].clientY; 
    } 
  });
    
  renderer.domElement.addEventListener("touchmove",(e)=>{ 
    if (isDragging && currentModel && e.touches.length===1) { 
      const dx=e.touches[0].clientX-previousTouchX; 
      const dy=e.touches[0].clientY-previousTouchY; 
      previousTouchX=e.touches[0].clientX; 
      previousTouchY=e.touches[0].clientY; 
      if (adjustMode) {
        // Dịch theo trục X (horizontal drag)
        translateAlongLocalAxis(new THREE.Vector3(1, 0, 0), dx * 0.001); // Factor nhạy
        // Dịch theo trục Y (vertical drag, negate để up drag positive Y)
        translateAlongLocalAxis(new THREE.Vector3(0, 1, 0), -dy * 0.001);
      }
    } 
  });
    
  renderer.domElement.addEventListener("touchend",()=>{ isDragging=false; });
  window.addEventListener("resize",()=>{ 
    camera.aspect = window.innerWidth/window.innerHeight; 
    camera.updateProjectionMatrix(); 
    renderer.setSize(window.innerWidth, window.innerHeight); 
  });
  </script>
</body>
</html>
