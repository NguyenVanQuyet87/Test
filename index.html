<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <title>WebXR AR với Marker Tracking và Hiệu Ứng Quét (Có Gizmo chỉnh sửa)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }

    #opacityControl {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10;
    }
    #info {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 10;
      background: rgba(0,0,0,0.4);
      color: white;
      padding: 6px 8px;
      font-family: monospace;
      font-size: 13px;
      border-radius: 6px;
      white-space: pre-line;
      max-width: 80%;
    }
    #resetBtn {
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 10;
      background: rgba(255,255,255,0.9);
      color: #111;
      padding: 6px 10px;
      font-family: system-ui, sans-serif;
      font-size: 13px;
      border: 1px solid #ccc;
      border-radius: 6px;
      cursor: pointer;
    }
    #markerStatus {
      position: absolute;
      bottom: 60px;
      left: 10px;
      z-index: 10;
      background: rgba(0,0,0,0.4);
      color: white;
      padding: 6px 8px;
      font-family: monospace;
      font-size: 13px;
      border-radius: 6px;
    }
    #placementBtn {
      position: absolute;
      bottom: 100px;
      right: 10px;
      z-index: 10;
      background: rgba(255,255,255,0.9);
      color: #111;
      padding: 8px 12px;
      font-family: system-ui, sans-serif;
      font-size: 13px;
      border: 1px solid #ccc;
      border-radius: 6px;
      cursor: pointer;
      display: none;
    }

    /* Overlay hiệu ứng quét QR code */
    #markerOverlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 5;
      display: none;
    }
    .qr-frame {
      position: absolute;
      border: 4px solid transparent;
      border-radius: 12px;
      box-shadow: 0 0 20px rgba(255, 255, 0, 0.7);
      animation: pulse 1.5s infinite alternate;
    }
    .qr-corner { position: absolute; width: 20px; height: 20px; border: 4px solid #ff0; }
    .qr-corner-tl { top: -4px; left: -4px; border-right: none; border-bottom: none; border-top-left-radius: 8px; }
    .qr-corner-tr { top: -4px; right: -4px; border-left: none; border-bottom: none; border-top-right-radius: 8px; }
    .qr-corner-bl { bottom: -4px; left: -4px; border-right: none; border-top: none; border-bottom-left-radius: 8px; }
    .qr-corner-br { bottom: -4px; right: -4px; border-left: none; border-top: none; border-bottom-right-radius: 8px; }
    .scan-line { position: absolute; height: 3px; width: 100%; background: linear-gradient(to right, transparent, #ff0, transparent); top: 50%; animation: scan 2s linear infinite; }
    @keyframes pulse { 0% { box-shadow: 0 0 10px rgba(255, 255, 0, 0.5); } 100% { box-shadow: 0 0 30px rgba(255, 255, 0, 1); } }
    @keyframes scan { 0% { top: 0%; opacity: 0; } 10% { opacity: 1; } 90% { opacity: 1; } 100% { top: 100%; opacity: 0; } }

    /* --- ADDED: UI controls for editing --- */
    /* Focus ring (different name than reticle) */
    #focusRing {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 34px;
      height: 34px;
      margin-left: -17px;
      margin-top: -17px;
      border: 2px solid rgba(255,255,255,0.9);
      border-radius: 50%;
      z-index: 12;
      pointer-events: none;
    }

    /* Buttons group (right center) */
    #funcGroup {
      position: absolute;
      right: 12px;
      top: 50%;
      transform: translateY(-50%);
      display: flex;
      flex-direction: column;
      gap: 8px;
      z-index: 12;
    }
    .funcBtn {
      background: rgba(255,255,255,0.95);
      border: 1px solid #ccc;
      padding: 8px 10px;
      border-radius: 8px;
      font-family: system-ui, sans-serif;
      font-size: 13px;
      cursor: pointer;
      min-width: 110px;
      text-align: center;
    }

    /* Left vertical slider (height) */
    #heightControl {
      position: absolute;
      left: 12px;
      top: 50%;
      transform: translateY(-50%) rotate(-90deg); /* rotate so it looks vertical, we'll interpret value */
      z-index: 12;
      pointer-events: auto;
    }

    /* Bottom rotation slider */
    #rotateControl {
      position: absolute;
      left: 50%;
      bottom: 12px;
      transform: translateX(-50%);
      z-index: 12;
      pointer-events: auto;
    }

    /* Small label style */
    .smallLabel {
      position: absolute;
      z-index: 12;
      color: white;
      font-family: monospace;
      font-size: 12px;
      background: rgba(0,0,0,0.4);
      padding: 4px 6px;
      border-radius: 6px;
    }
    #heightLabel { left: 12px; top: calc(50% - 80px); transform: none; }
    #rotateLabel { left: 50%; bottom: 48px; transform: translateX(-50%); }
  </style>
</head>
<body>
  <div id="info">Đang chờ khởi động AR...</div>
  <div id="markerStatus">Chưa phát hiện marker</div>
  <button id="resetBtn" type="button">Reset AR</button>
  <button id="placementBtn" type="button">Đặt mô hình</button>
  <input type="range" id="opacityControl" min="0" max="1" step="0.05" value="1">
  
  <!-- Overlay hiệu ứng quét QR code -->
  <div id="markerOverlay">
    <div class="qr-frame">
      <div class="qr-corner qr-corner-tl"></div>
      <div class="qr-corner qr-corner-tr"></div>
      <div class="qr-corner qr-corner-bl"></div>
      <div class="qr-corner qr-corner-br"></div>
      <div class="scan-line"></div>
    </div>
  </div>

  <!-- ADDED UI -->
  <div id="focusRing"></div> <!-- small static ring at center (not the XR reticle) -->
  <div id="funcGroup">
    <button id="adjustBtn" class="funcBtn">Adjust: Off</button>
    <button id="opacityBtn" class="funcBtn">Hide Model</button>
    <button id="resetTransformBtn" class="funcBtn">Reset Transform</button>
  </div>

  <input id="heightControl" type="range" min="-1" max="1" step="0.01" value="0" />
  <div id="heightLabel" class="smallLabel">Height: 0.00m</div>

  <input id="rotateControl" type="range" min="-180" max="180" step="1" value="0" />
  <div id="rotateLabel" class="smallLabel">Rotate: 0°</div>

  <script type="module">
  import * as THREE from "https://esm.sh/three@0.160.0";
  import { GLTFLoader } from "https://esm.sh/three@0.160.0/examples/jsm/loaders/GLTFLoader.js";
  import { ARButton } from "https://esm.sh/three@0.160.0/examples/jsm/webxr/ARButton.js";

  const infoEl = document.getElementById("info");
  const markerStatusEl = document.getElementById("markerStatus");
  const resetBtn = document.getElementById("resetBtn");
  const placementBtn = document.getElementById("placementBtn");
  const markerOverlay = document.getElementById("markerOverlay");
  const qrFrame = document.querySelector('.qr-frame');

  // ADDED UI controls
  const focusRing = document.getElementById("focusRing");
  const adjustBtn = document.getElementById("adjustBtn");
  const opacityBtn = document.getElementById("opacityBtn");
  const resetTransformBtn = document.getElementById("resetTransformBtn");
  const heightControl = document.getElementById("heightControl");
  const heightLabel = document.getElementById("heightLabel");
  const rotateControl = document.getElementById("rotateControl");
  const rotateLabel = document.getElementById("rotateLabel");

  let modelTemplate = null;
  let currentAnchor = null;
  let reticle;
  let hitTestSource = null;
  let lastHitResult = null;
  let currentModel = null;
  let isDragging = false;
  let previousTouchX = 0;
  let isPlacing = false;
  let markerDetected = false;
  let markerPose = null;
  const allAnchors = new Set();

  // ADDED: gizmo state
  let gizmoVisible = false;
  let gizmoGroup = null;
  let axisHandles = {}; // { 'X': mesh, 'Y': mesh }
  let draggingState = { active:false, axis:null, basePos: null, baseQuat: null, startIntersection: null };

  // For slider base states (set when opening adjust mode or after placement)
  let basePosition = new THREE.Vector3();
  let baseQuaternion = new THREE.Quaternion();

  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.01, 20);
  const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.xr.enabled = true;
  document.body.appendChild(renderer.domElement);

  const PLACEMENTS_ROOT = new THREE.Group();
  scene.add(PLACEMENTS_ROOT);

  // Hàm cập nhật vị trí và kích thước của hiệu ứng quét QR dựa trên vị trí marker
  function updateQRFramePosition(pose) {
    if (!pose) return;
    const matrix = new THREE.Matrix4().fromArray(pose.transform.matrix);
    const position = new THREE.Vector3();
    const scale = new THREE.Vector3();
    const quaternion = new THREE.Quaternion();
    matrix.decompose(position, quaternion, scale);
    const vector = position.clone();
    vector.project(camera);
    const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
    const y = -(vector.y * 0.5 - 0.5) * window.innerHeight;
    const distance = position.distanceTo(camera.position);
    const markerSize = (0.15 / distance) * 500; // magic scale factor
    qrFrame.style.width = `${markerSize}px`;
    qrFrame.style.height = `${markerSize}px`;
    qrFrame.style.left = `${x - markerSize/2}px`;
    qrFrame.style.top = `${y - markerSize/2}px`;
    markerOverlay.style.display = 'block';
  }
  function hideQRFrame() { markerOverlay.style.display = 'none'; }

  async function initARButton() {
    if (!("xr" in navigator)) { infoEl.textContent = "Trình duyệt không hỗ trợ WebXR."; return; }
    const supported = await navigator.xr.isSessionSupported("immersive-ar");
    if (!supported) { infoEl.textContent = "Thiết bị không hỗ trợ AR."; return; }
    try {
      const imgBitmap = await fetch("marker.png")
        .then(r => r.blob())
        .then(b => createImageBitmap(b));
      document.body.appendChild(ARButton.createButton(renderer, {
        requiredFeatures: ["image-tracking"],
        trackedImages: [
          { image: imgBitmap, widthInMeters: 0.15 }
        ],
        optionalFeatures: ["hit-test", "anchors", "dom-overlay"],
        domOverlay: { root: document.body }
      }));
    } catch (e) {
      console.error("Lỗi khi tải marker:", e);
      infoEl.textContent = "Lỗi khi tải marker.png - vui lòng kiểm tra file và console";
    }
  }
  initARButton();

  scene.add(new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1));

  const ringGeo = new THREE.RingGeometry(0.08,0.1,32).rotateX(-Math.PI/2);
  const ringMat = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
  reticle = new THREE.Mesh(ringGeo, ringMat);
  reticle.matrixAutoUpdate = false;
  reticle.visible = false;
  scene.add(reticle);

  function createFallbackModel() {
    const geometry = new THREE.BoxGeometry(0.1, 0.1, 0.1);
    const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
    const cube = new THREE.Mesh(geometry, material);
    const group = new THREE.Group();
    group.add(cube);
    group.scale.set(0.2, 0.2, 0.2);
    return group;
  }

  // Hệ tọa độ của file GLTF: thường +Y up; bạn xoay nếu cần
  const loader = new GLTFLoader();
  loader.load("test.glb", (gltf)=>{
    modelTemplate = gltf.scene;
    modelTemplate.scale.set(0.2,0.2,0.2);
    // Nếu mô hình xuất từ IFC/glTF có up khác, điều chỉnh 1 lần
    modelTemplate.rotation.x = Math.PI / 2; // bạn có thể đổi lại nếu không hợp
    console.log(gltf.scene);
    console.log(gltf.parser);
    infoEl.textContent = "Model đã load — di chuyển camera để tìm mặt phẳng hoặc marker.";
  }, undefined, (err)=>{
    console.error("GLTF load error:", err);
    infoEl.textContent = "Lỗi load GLTF — tạo model mẫu thay thế.";
    modelTemplate = createFallbackModel();
  });

  function cloneModel(template) {
    const clone = template.clone(true);
    clone.traverse((n)=>{
      if (n.isMesh && n.material) {
        n.material = n.material.clone();
        n.material.transparent = true;
        n.material.userData.__cloned = true;
      }
    });
    return clone;
  }

  function clearAllPlacementsAndAnchors() {
    if (allAnchors.size) {
      for (const a of allAnchors) { try { if (a.delete) a.delete(); } catch(e){} }
      allAnchors.clear();
    }
    while (PLACEMENTS_ROOT.children.length) {
      const child = PLACEMENTS_ROOT.children[0];
      PLACEMENTS_ROOT.remove(child);
    }
    currentAnchor = null;
    currentModel = null;
    // hide gizmo if any
    hideGizmo();
  }

  // --- placeModelOnMarker (MODIFIED) ---
  function placeModelOnMarker(pose) {
    if (!modelTemplate || isPlacing) return;
    isPlacing = true;
    clearAllPlacementsAndAnchors();

    const group = new THREE.Group();
    // Sử dụng ma trận từ pose của marker
    const matrix = new THREE.Matrix4().fromArray(pose.transform.matrix);
    const position = new THREE.Vector3();
    const quaternion = new THREE.Quaternion();
    const scale = new THREE.Vector3();
    matrix.decompose(position, quaternion, scale);

    // Các trục local theo WebXR convention: Y = normal (up)
    const localX = new THREE.Vector3(1,0,0);
    const localY = new THREE.Vector3(0,1,0);
    const localZ = new THREE.Vector3(0,0,1);

    const markerRight  = localX.clone().applyQuaternion(quaternion);
    const markerNormal = localY.clone().applyQuaternion(quaternion);
    const markerForward= localZ.clone().applyQuaternion(quaternion);

    // Map theo yêu cầu: +X model = vào marker (ngược normal), +Y sang trái (ngược right), +Z lên trên (forward hoặc marker up)
    let modelXAxis = markerNormal.clone().negate();   // vào marker
    let modelYAxis = markerRight.clone().negate();    // sang trái
    let modelZAxis = markerForward.clone();           // lên trên (có thể đổi nếu cần)

    // Chuẩn hoá và tạo ma trận
    modelXAxis.normalize();
    modelZAxis.normalize();
    modelYAxis.copy(new THREE.Vector3().crossVectors(modelZAxis, modelXAxis)).normalize();

    const modelMatrix = new THREE.Matrix4().makeBasis(modelXAxis, modelYAxis, modelZAxis);
    modelMatrix.setPosition(position);

    // Áp dụng ma trận cho group BUT để dễ thao tác, chuyển sang position/quaternion và bật matrixAutoUpdate
    group.matrix.copy(modelMatrix);
    // decompose group.matrix -> position/quaternion/scale
    const gpPos = new THREE.Vector3();
    const gpQuat = new THREE.Quaternion();
    const gpScale = new THREE.Vector3();
    group.matrix.decompose(gpPos, gpQuat, gpScale);
    group.position.copy(gpPos);
    group.quaternion.copy(gpQuat);
    group.scale.copy(gpScale);
    group.matrixAutoUpdate = true; // --- ADDED: cho phép update bằng position/quaternion

    PLACEMENTS_ROOT.add(group);

    const placed = cloneModel(modelTemplate);
    group.add(placed);
    currentModel = placed;

    // lưu base states cho sliders
    basePosition.copy(group.position);
    baseQuaternion.copy(group.quaternion);

    // tạo gizmo (nhưng ẩn mặc định)
    createGizmo(group);
    hideGizmo();

    // Tạo anchor nếu có thể
    if (pose && pose.createAnchor) {
      pose.createAnchor().then(anchor => {
        currentAnchor = { anchor, group };
        allAnchors.add(anchor);
      }).catch(console.error);
    }

    infoEl.textContent = "Model đã được đặt trên marker! Trục +X vào marker, +Y sang trái, +Z lên trên.";
    isPlacing = false;
    markerDetected = false;
    hideQRFrame();

    // Debug: (nếu muốn) hiển thị trục bằng lines (giữ lại hàm debugAxes)
    // debugAxes(group, modelXAxis, modelYAxis, modelZAxis);
  }

  // --- ADDED: Gizmo creation ---
  function createGizmo(parentGroup) {
    // Remove old gizmo if exists
    if (gizmoGroup) {
      parentGroup.remove(gizmoGroup);
      gizmoGroup = null;
      axisHandles = {};
    }

    const g = new THREE.Group();
    g.name = "gizmoGroup";

    const axisLength = 0.6;

    // X axis dashed line (red) - along parent's local X
    const xPoints = [ new THREE.Vector3(0,0,0), new THREE.Vector3(axisLength,0,0) ];
    const xGeo = new THREE.BufferGeometry().setFromPoints(xPoints);
    const xMat = new THREE.LineDashedMaterial({ color:0xff0000, dashSize:0.03, gapSize:0.02, linewidth:1 });
    const xLine = new THREE.Line(xGeo, xMat);
    xLine.computeLineDistances();
    xLine.name = "gizmo_line_X";
    g.add(xLine);

    // Y axis dashed line (green) - along parent's local Y
    const yPoints = [ new THREE.Vector3(0,0,0), new THREE.Vector3(0,axisLength,0) ];
    const yGeo = new THREE.BufferGeometry().setFromPoints(yPoints);
    const yMat = new THREE.LineDashedMaterial({ color:0x00ff00, dashSize:0.03, gapSize:0.02, linewidth:1 });
    const yLine = new THREE.Line(yGeo, yMat);
    yLine.computeLineDistances();
    yLine.name = "gizmo_line_Y";
    g.add(yLine);

    // Arrow heads (cones) at the end of axes to act as handles
    const coneGeom = new THREE.ConeGeometry(0.02, 0.06, 12);

    // X handle (red)
    const xHandle = new THREE.Mesh(coneGeom, new THREE.MeshBasicMaterial({ color:0xff0000 }));
    xHandle.name = "gizmo_handle_X";
    xHandle.position.set(axisLength, 0, 0);
    xHandle.rotation.z = -Math.PI/2; // point along +X
    g.add(xHandle);

    // Y handle (green)
    const yHandle = new THREE.Mesh(coneGeom, new THREE.MeshBasicMaterial({ color:0x00ff00 }));
    yHandle.name = "gizmo_handle_Y";
    yHandle.position.set(0, axisLength, 0);
    // default cone points -Y, rotate so points +Y
    yHandle.rotation.x = Math.PI/2;
    g.add(yHandle);

    // store references
    axisHandles = { X: xHandle, Y: yHandle };
    gizmoGroup = g;

    // add as child so it inherits parentGroup transforms
    parentGroup.add(gizmoGroup);
  }

  function showGizmo() {
    if (!gizmoGroup || !currentModel) return;
    gizmoGroup.visible = true;
    gizmoVisible = true;
    adjustBtn.textContent = "Adjust: On";
    // set base states for sliders
    if (gizmoGroup.parent) { // group is parentGroup
      basePosition.copy(gizmoGroup.parent.position);
      baseQuaternion.copy(gizmoGroup.parent.quaternion);
      heightControl.value = 0;
      rotateControl.value = 0;
      heightLabel.textContent = `Height: 0.00m`;
      rotateLabel.textContent = `Rotate: 0°`;
    }
  }
  function hideGizmo() {
    if (!gizmoGroup) return;
    gizmoGroup.visible = false;
    gizmoVisible = false;
    adjustBtn.textContent = "Adjust: Off";
  }

  // --- ADDED: Pointer interaction for gizmo handles ---
  const pointerRaycaster = new THREE.Raycaster();
  const pointer = new THREE.Vector2();

  function onPointerDown(e) {
    if (!gizmoVisible || !gizmoGroup) return;
    const rect = renderer.domElement.getBoundingClientRect();
    pointer.x = ( (e.clientX - rect.left) / rect.width ) * 2 - 1;
    pointer.y = - ( (e.clientY - rect.top) / rect.height ) * 2 + 1;
    pointerRaycaster.setFromCamera(pointer, camera);
    // pick handles
    const hits = pointerRaycaster.intersectObjects(Object.values(axisHandles), true);
    if (hits.length > 0) {
      const picked = hits[0].object;
      // determine axis
      const axis = picked.name.includes("_X") || picked.name.includes("handle_X") ? 'X' : 'Y';
      startDragAxis(axis, e);
      e.preventDefault();
    }
  }

  function startDragAxis(axis, event) {
    if (!gizmoGroup || !gizmoGroup.parent) return;
    draggingState.active = true;
    draggingState.axis = axis;
    // record base state
    draggingState.basePos = gizmoGroup.parent.position.clone();
    draggingState.baseQuat = gizmoGroup.parent.quaternion.clone();
    // compute axis direction in world space
    const axisDirLocal = (axis === 'X') ? new THREE.Vector3(1,0,0) : new THREE.Vector3(0,1,0);
    const axisDirWorld = axisDirLocal.clone().applyQuaternion(gizmoGroup.parent.quaternion).normalize();
    draggingState.axisDirWorld = axisDirWorld;
    // compute intersection of pointer ray with plane perpendicular to axis, to record startIntersection
    const rect = renderer.domElement.getBoundingClientRect();
    pointer.x = ( (event.clientX - rect.left) / rect.width ) * 2 - 1;
    pointer.y = - ( (event.clientY - rect.top) / rect.height ) * 2 + 1;
    pointerRaycaster.setFromCamera(pointer, camera);
    const plane = new THREE.Plane().setFromNormalAndCoplanarPoint(axisDirWorld, gizmoGroup.parent.position);
    const inter = pointerRaycaster.ray.intersectPlane(plane, new THREE.Vector3());
    draggingState.startIntersection = inter ? inter.clone() : null;
  }

  function onPointerMove(e) {
    if (!draggingState.active) return;
    const rect = renderer.domElement.getBoundingClientRect();
    pointer.x = ( (e.clientX - rect.left) / rect.width ) * 2 - 1;
    pointer.y = - ( (e.clientY - rect.top) / rect.height ) * 2 + 1;
    pointerRaycaster.setFromCamera(pointer, camera);
    const plane = new THREE.Plane().setFromNormalAndCoplanarPoint(draggingState.axisDirWorld, gizmoGroup.parent.position);
    const inter = pointerRaycaster.ray.intersectPlane(plane, new THREE.Vector3());
    if (!inter || !draggingState.startIntersection) return;
    // compute displacement along axis: project (inter - basePoint) onto axisDirWorld
    const v = inter.clone().sub(draggingState.startIntersection);
    const disp = v.dot(draggingState.axisDirWorld);
    // update position = basePos + axisDirWorld * disp
    const newPos = draggingState.basePos.clone().add(draggingState.axisDirWorld.clone().multiplyScalar(disp));
    gizmoGroup.parent.position.copy(newPos);
    // update base states for sliders too (so slider reflect relation)
    basePosition.copy(gizmoGroup.parent.position);
    // ensure gizmo stays visible
  }

  function onPointerUp(e) {
    if (draggingState.active) {
      draggingState.active = false;
      draggingState.axis = null;
      draggingState.startIntersection = null;
    }
  }

  // Attach pointer listeners (works for mouse & touch)
  renderer.domElement.addEventListener('pointerdown', onPointerDown);
  window.addEventListener('pointermove', onPointerMove);
  window.addEventListener('pointerup', onPointerUp);

  // --- ADDED: Height and Rotation controls logic ---
  heightControl.addEventListener('input', (e) => {
    if (!gizmoGroup || !gizmoGroup.parent) return;
    const val = parseFloat(e.target.value);
    // val maps -1..1 meters relative to basePosition (you can change scale)
    const meter = val; // 1 unit = 1 meter; change multiplier if needed
    const upAxisLocal = new THREE.Vector3(0,0,1); // in parent local we considered Z up for model
    // convert local up to world
    const upWorld = upAxisLocal.applyQuaternion(gizmoGroup.parent.quaternion).normalize();
    const newPos = basePosition.clone().add(upWorld.multiplyScalar(meter));
    gizmoGroup.parent.position.copy(newPos);
    heightLabel.textContent = `Height: ${meter.toFixed(2)}m`;
  });

  // rotation slider: rotate around up axis (world) relative to baseQuaternion
  rotateControl.addEventListener('input', (e) => {
    if (!gizmoGroup || !gizmoGroup.parent) return;
    const deg = parseFloat(e.target.value);
    const rad = deg * Math.PI / 180;
    // up axis in world: local (0,0,1) transformed by baseQuaternion
    const upLocal = new THREE.Vector3(0,0,1).applyQuaternion(baseQuaternion).normalize();
    const q = new THREE.Quaternion().setFromAxisAngle(upLocal, rad);
    const newQuat = baseQuaternion.clone().multiply(q);
    gizmoGroup.parent.quaternion.copy(newQuat);
    rotateLabel.textContent = `Rotate: ${deg}°`;
  });

  // When toggling adjust mode
  adjustBtn.addEventListener('click', () => {
    if (!currentModel || !gizmoGroup) return;
    gizmoVisible ? hideGizmo() : showGizmo();
  });

  // Opacity / hide model
  opacityBtn.addEventListener('click', () => {
    if (!currentModel) return;
    currentModel.visible = !currentModel.visible;
    opacityBtn.textContent = currentModel.visible ? "Hide Model" : "Show Model";
  });

  // Reset transform to base (the base is set on placement)
  resetTransformBtn.addEventListener('click', () => {
    if (!gizmoGroup || !gizmoGroup.parent) return;
    gizmoGroup.parent.position.copy(basePosition);
    gizmoGroup.parent.quaternion.copy(baseQuaternion);
    heightControl.value = 0;
    rotateControl.value = 0;
    heightLabel.textContent = `Height: 0.00m`;
    rotateLabel.textContent = `Rotate: 0°`;
  });

  // --- existing orientation helpers etc (kept) ---
  let _lastHDir = new THREE.Vector3(1, 0, 0);
  function getCameraHorizontalDir() {
    const fwd = new THREE.Vector3();
    camera.getWorldDirection(fwd);
    fwd.y = 0;
    const len = fwd.length();
    if (len < 1e-3) return _lastHDir.clone();
    fwd.divideScalar(len);
    _lastHDir.copy(fwd);
    return fwd;
  }

  function computePlacementMatrixFromMatrix(baseMatrix) {
    const poseMat = new THREE.Matrix4().copy(baseMatrix);
    const rotMat = new THREE.Matrix4().extractRotation(poseMat);
    const normal = new THREE.Vector3(0,1,0).applyMatrix4(rotMat).normalize();
    const camH = getCameraHorizontalDir();
    const camProj = camH.clone().projectOnPlane(normal);
    if (camProj.length() < 1e-3) {
      camProj.copy(_lastHDir).projectOnPlane(normal);
      if (camProj.length() < 1e-3) camProj.set(1,0,0);
    }
    camProj.normalize();
    const xAxis = camProj.clone();
    const yAxis = normal.clone().normalize();
    const zAxis = new THREE.Vector3().crossVectors(yAxis, xAxis).normalize();
    const basis = new THREE.Matrix4().makeBasis(xAxis, yAxis, zAxis);
    const pos = new THREE.Vector3().setFromMatrixPosition(poseMat);
    basis.setPosition(pos);
    return basis;
  }

  async function placeAnchorFromLastHit() {
    if (isPlacing) return;
    isPlacing = true;
    const hit = lastHitResult;
    const refSpace = renderer.xr.getReferenceSpace();
    if (!hit || !refSpace || !modelTemplate) { isPlacing=false; return; }
    clearAllPlacementsAndAnchors();
    const pose = hit.getPose(refSpace);
    const anchor = await hit.createAnchor?.(refSpace).catch(()=>null);
    const group = new THREE.Group();
    group.matrixAutoUpdate=false;
    if (pose) {
      const placementMatrix = computePlacementMatrixFromMatrix(new THREE.Matrix4().fromArray(pose.transform.matrix));
      group.matrix.copy(placementMatrix);
    }
    PLACEMENTS_ROOT.add(group);
    const placed = cloneModel(modelTemplate);
    group.add(placed);
    currentModel = placed;
    currentAnchor = { anchor, group };
    if (anchor) allAnchors.add(anchor);

    // Make group manipulable like placeModelOnMarker: move matrix to pos/quaternion and enable autoUpdate
    const gpPos = new THREE.Vector3(), gpQuat = new THREE.Quaternion(), gpScale = new THREE.Vector3();
    group.matrix.decompose(gpPos, gpQuat, gpScale);
    group.position.copy(gpPos);
    group.quaternion.copy(gpQuat);
    group.scale.copy(gpScale);
    group.matrixAutoUpdate = true;

    // create gizmo attached
    createGizmo(group);
    hideGizmo();

    // update base states
    basePosition.copy(group.position);
    baseQuaternion.copy(group.quaternion);

    isPlacing=false;
  }

  const controller = renderer.xr.getController(0);
  controller.addEventListener("select", ()=>{ if (reticle.visible) placeAnchorFromLastHit(); });
  scene.add(controller);
  
  window.addEventListener("click", ()=>{ 
    const s=renderer.xr.getSession(); 
    if (s && reticle.visible) placeAnchorFromLastHit(); 
  });

  placementBtn.addEventListener("click", ()=>{ if (markerPose) { placeModelOnMarker(markerPose); placementBtn.style.display = 'none'; } });

  document.getElementById("opacityControl").addEventListener("input",(e)=>{ const v = parseFloat(e.target.value); if (currentModel) { currentModel.traverse((n)=>{ if (n.isMesh && n.material) n.material.opacity=v; }); }});

  resetBtn.addEventListener("click",()=>{ const s=renderer.xr.getSession(); if (s) s.end(); hideQRFrame(); });

  renderer.xr.addEventListener("sessionstart", async ()=>{
    const session = renderer.xr.getSession();
    infoEl.textContent = "Đã vào chế độ AR, di chuyển để quét mặt phẳng hoặc marker...";
    const viewerSpace = await session.requestReferenceSpace("viewer");
    hitTestSource = await session.requestHitTestSource({ space: viewerSpace }).catch(()=>null);
    session.addEventListener("end", ()=>{ 
      hitTestSource = null; 
      clearAllPlacementsAndAnchors(); 
      infoEl.textContent = "AR session đã kết thúc.";
      markerStatusEl.textContent = "Chưa phát hiện marker";
      placementBtn.style.display = 'none';
      markerDetected = false;
      hideQRFrame();
    });
  });

  // --- ADDED: center cone selection multi-ray logic for stable selection on mobile ---
  const raycaster = new THREE.Raycaster();
  const center = new THREE.Vector2(0, 0);
  function getIntersects() {
    const offsets = [
      new THREE.Vector2(0, 0),
      new THREE.Vector2(0.01, 0),
      new THREE.Vector2(-0.01, 0),
      new THREE.Vector2(0, 0.01),
      new THREE.Vector2(0, -0.01)
    ];
    let allHits = [];
    offsets.forEach(off => {
      const ndc = new THREE.Vector2(center.x + off.x, center.y + off.y);
      raycaster.setFromCamera(ndc, camera);
      const hits = raycaster.intersectObjects(scene.children, true);
      if (hits.length > 0) allHits.push(hits[0]);
    });
    if (allHits.length > 0) {
      allHits.sort((a,b) => a.distance - b.distance);
      return allHits[0];
    } else {
      // fallback: check if camera inside any object's world bounding box (helps when camera is very close)
      for (const obj of scene.children) {
        if (obj.isMesh) {
          if (!obj.geometry.boundingBox) obj.geometry.computeBoundingBox();
          const box = obj.geometry.boundingBox.clone().applyMatrix4(obj.matrixWorld);
          if (box.containsPoint(camera.position)) {
            return { object: obj, distance: 0 };
          }
        }
      }
    }
    return null;
  }

  renderer.setAnimationLoop((t,frame)=>{
    if (frame) {
      const refSpace = renderer.xr.getReferenceSpace();
      if (hitTestSource && refSpace) {
        const hits = frame.getHitTestResults(hitTestSource);
        if (hits.length>0) {
          lastHitResult = hits[0];
          const pose = hits[0].getPose(refSpace);
          if (pose) { reticle.visible=true; reticle.matrix.fromArray(pose.transform.matrix); }
        } else { reticle.visible=false; }
      }

      // Image tracking
      const results = frame.getImageTrackingResults ? frame.getImageTrackingResults() : [];
      if (results.length > 0) {
        for (const result of results) {
          const state = result.trackingState;
          if (state === "tracked") {
            const pose = frame.getPose(result.imageSpace, refSpace);
            if (pose) {
              const p = pose.transform.position;
              markerStatusEl.textContent = `Marker được nhận diện!\nVị trí: x=${p.x.toFixed(2)}, y=${p.y.toFixed(2)}, z=${p.z.toFixed(2)}`;
              updateQRFramePosition(pose);
              markerPose = pose;
              if (!currentModel && modelTemplate && !markerDetected) {
                markerDetected = true;
                placementBtn.style.display = 'block';
                placementBtn.textContent = 'Đặt mô hình lên marker';
                setTimeout(() => {
                  if (markerDetected && markerPose) {
                    placeModelOnMarker(markerPose);
                    placementBtn.style.display = 'none';
                  }
                }, 2000);
              }
            }
          } else {
            markerStatusEl.textContent = `Marker trạng thái: ${state}`;
            markerDetected = false;
            placementBtn.style.display = 'none';
            hideQRFrame();
          }
        }
      } else {
        markerStatusEl.textContent = "Chưa phát hiện marker";
        markerDetected = false;
        placementBtn.style.display = 'none';
        hideQRFrame();
      }

      // --- ADDED: Center-based selection (cone) to highlight selected object ---
      const hit = getIntersects();
      if (hit && hit.object) {
        const obj = hit.object;
        // simple highlight: change color if mesh material exists
        if (obj.material) {
          try { obj.material.emissive && obj.material.emissive.setHex(0x222222); } catch(e) {}
        }
        // show some info
        // (You may want to show obj.userData or GUID mapping)
        // infoEl.textContent = `Chọn: ${obj.name || obj.uuid}`;
      } else {
        // nothing intersected - optionally clear highlight (omitted for performance)
      }
    }

    renderer.render(scene, camera);
  });

  // pointer handlers already set earlier
  // window resize
  window.addEventListener("resize",()=>{ camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });

  // --- End of script ---
  </script>
</body>
</html>
